# Higher-Order Logic with Isabelle/HOL

*Author: Spencer Au*

## Contents

| Section | Title |
|---:|---|
| **10.1** | [Idea](#sec0-10-1) |
| **10.2** | [Basic Theory](#sec0-10-2) |
| **10.3** | [Tool (Installation, First Example, First Exercise)](#sec0-10-3) |
| **10.4** | [Introductory Examples](#sec0-10-4) |
| **10.5** | [The Landscape of Tools](#sec0-10-5) |
| **10.6** | [Algorithms](#sec0-10-6) |
| **10.7** | [Benchmark and Competitions](#sec0-10-7) |
| **10.8** | [Applications in Industry](#sec0-10-8) |
| **10.9** | [Case Studies](#sec0-10-9) |
| **10.10** | [History](#sec0-10-10) |
| **10.11** | [Current Development, Research Challenges, Conferences and Workshops](#sec0-10-11) |
| **10.12** | [References](#sec0-10-12) |
| **10.13** | [Suggestions for Future Work](#sec0-10-13) |

## Topics

- Higher-order logic foundations
- Function types and quantification
- Isabelle/HOL advanced features
- Theorem proving strategies
- Industrial theorem proving

## 10.1 Idea and Introduction {#sec0-10-1}
WIP

This chapter extends to higher-order logic in Isabelle/HOL, showing how to reason about functions as first-class objects and exploring the foundations of modern theorem proving.

Higher-order logic (HOL) extends the capabilities of first-order logic (FOL) by allowing quantifiers (such as $ \forall x $ and $ \exists x $) to range over functions and predicates, not just individual elements. In addition, functions can be passed as arguments to other functions, returned as results, and manipulated just like any other data type. This enables more expressive statements about the properties of functions and their relationships.

## 10.2 Basic Theory {#sec0-10-2}
WIP

<!-- basic setup - need to add much more but this is just basics/scaffolding -->

### 10.2.1 First Order Logic 
WIP
$ \forall x $ and $ \exists x$ where x is a variable/individual element

### 10.2.2 Higher Order Logic 
WIP
$ \forall f(x) $ and $ \exists f(x) $ where x is a function that takes x as an input


## 10.3 Tool (Installation, First Example, First Exercise) {#sec0-10-3}

### 10.3.1 Installation
WIP

<!-- Looks like isabelle is a program we can just download normally via exe/dmg etc instead of messing around with command line or using `apt/brew` -->

[Installation Link for Isabelle](https://isabelle.in.tum.de/)

<!-- probably have detailed walkthrough for windows, macos, and ubuntu with pictures etc all that with pictures and all that pretty stuff (remove if it results in the chapter being too long) -->

Isabelle processes the theory document incrementally in the background, meaning that there is no additional "compile" or "run" step. As you type in lines and commands, the background system will check them and automatically update the proof state and any relevant error reports. Just go line by line, or command by command in order to check the related output.

### 10.3.2 First Example

Create a file called `hello_world.thy`, which will be an introductionary "hello world" type theory to onboard the basics of Isabelle and the HOL language. The beginning of the file should look like this:

```isabelle
theory hello_world 
    imports Main
begin

THEORY BODY

end
```

`theory hello_world` declares the theory name and **must** exactly match the .thy filename. For example, if the file is called test.thy, then you would have `theory test`

`imports Main` tells it to import another theory; in this case that is Main.thy, which includes support for natural numbers, lists, and basic arithmetic

`begin` is the entry point into the theory body, while `end` is the end point of the theory body

In order to declare a constant and assign it a value, we use this general structure:

```isabelle
definition NAME :: TYPE where 
    "NAME = VALUE"
```

In our specific `hello_world.thy`, we will be assigning the value of "Hello World!" to a constant named "greeting" of the type "string".

```isabelle
definition greeting :: string where
    "greeting = ''Hello World!''"
```

In Isabelle, using the `definition` keyword introduce a constant, not a mutable variable. This means that the value of greeting will be fixed, equialent to "Hello World!" and cannot change within this theory.

Next we will declare a new theorem using the `lemma` command. Note that the **lemma** and **theorem** are intechangeable within Isabelle. The general structure of a lemma declaration is:

```isabelle
lemma LEMMA_NAME: "GOAL"
    by (PROOF_METHOD)
```

For our Hello World theory, we will be declaring a theorem called "hello_greeting" that will be proving that the value of "greeting" is indeed "Hello World!"

```isabelle
lemma hello_greeting: "greeting = ''Hello World!''"
    by (simp add: greeting_def)
```

The `simp` command invokes Isabelle's simplify method, which attempts to reduce the goal by using rewrite rules and known equalities. Using `add: greeting_def` tells simp to use the definition theorem greeting_def (automatically generated by the defition declaration of greeting) as an extra rewrite rule to simplify the goal.

The complete theory for hello_world.thy looks like this:

```isabelle
theory hello_world 
    imports Main
begin

definition greeting :: string where
    "greeting = ''Hello World!''"

lemma hello_greeting: "greeting = ''Hello World!''"
    by (simp add: greeting_def)

end
```

### 10.3.3 First Exercise
WIP

## 10.4 Introductory Examples {#sec0-10-4}


## 10.5 The Landscape of Tools {#sec0-10-5}


## 10.6 Algorithms {#sec0-10-6}


## 10.7 Benchmark and Competitions {#sec0-10-7}


## 10.8 Applications in Industry {#sec0-10-8}


## 10.9 Case Studies {#sec0-10-9}


## 10.10 History {#sec0-10-10}


## 10.11 Current Development, Research Challenges, Conferences and Workshops {#sec0-10-11}


## 10.12 References {#sec0-10-12}

- [Isabelle/HOL](https://isabelle.in.tum.de/)
- [Concrete Semantics](http://www.concrete-semantics.org/)
- [Isabelle YouTube Tutorial by FDS 2020](https://www.youtube.com/@FDS-hs2uc/videos)
- [Syllogism Slides from Nate Moss](https://logic.berkeley.edu/colloquium/MossSlides.pdf)


## 10.13 Suggestions for Future Work {#sec0-10-13}

