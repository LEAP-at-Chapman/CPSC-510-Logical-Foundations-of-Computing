# Higher-Order Logic with Isabelle/HOL

*Author: Spencer Au*

## Contents

| Section | Title |
|---:|---|
| **10.1** | [Idea](#sec0-10-1) |
| **10.2** | [Basic Theory](#sec0-10-2) |
| **10.3** | [Tool (Installation, First Example, First Exercise)](#sec0-10-3) |
| **10.4** | [Introductory Examples](#sec0-10-4) |
| **10.5** | [The Landscape of Tools](#sec0-10-5) |
| **10.6** | [Algorithms](#sec0-10-6) |
| **10.7** | [Benchmark and Competitions](#sec0-10-7) |
| **10.8** | [Applications in Industry](#sec0-10-8) |
| **10.9** | [Case Studies](#sec0-10-9) |
| **10.10** | [History](#sec0-10-10) |
| **10.11** | [Current Development, Research Challenges, Conferences and Workshops](#sec0-10-11) |
| **10.12** | [References](#sec0-10-12) |
| **10.13** | [Suggestions for Future Work](#sec0-10-13) |

## Topics

- Higher-order logic foundations
- Function types and quantification
- Isabelle/HOL advanced features
- Theorem proving strategies
- Industrial theorem proving

## 10.1 Idea and Introduction {#sec0-10-1}
WIP

This chapter extends to higher-order logic in Isabelle/HOL, showing how to reason about functions as first-class objects and exploring the foundations of modern theorem proving.

Higher-order logic (HOL) extends the capabilities of first-order logic (FOL) by allowing quantifiers (such as $ \forall x $ and $ \exists x $) to range over functions and predicates, not just individual elements. In addition, functions can be passed as arguments to other functions, returned as results, and manipulated just like any other data type. This enables more expressive statements about the properties of functions and their relationships.

## 10.2 Basic Theory {#sec0-10-2}
WIP

<!-- basic setup - need to add much more but this is just basics/scaffolding -->

### 10.2.1 First Order Logic 
WIP
$ \forall x $ and $ \exists x$ where x is a variable/individual element

### 10.2.2 Higher Order Logic 
WIP
$ \forall f(x) $ and $ \exists f(x) $ where x is a function that takes x as an input


## 10.3 Tool (Installation, First Example, First Exercise) {#sec0-10-3}

### 10.3.1 Installation
WIP

<!-- Looks like isabelle is a program we can just download normally via exe/dmg etc instead of messing around with command line or using `apt/brew` -->

[Installation Link for Isabelle](https://isabelle.in.tum.de/)

<!-- probably have detailed walkthrough for windows, macos, and ubuntu with pictures etc all that with pictures and all that pretty stuff (remove if it results in the chapter being too long) -->

Isabelle processes the theory document incrementally in the background, meaning that there is no additional "compile" or "run" step. As you type in lines and commands, the background system will check them and automatically update the proof state and any relevant error reports. Just go line by line, or command by command in order to check the related output.

### 10.3.2 First Example

Create a file called `hello_world.thy`, which will be an introductionary "hello world" type theory to onboard the basics of Isabelle and the HOL language. The beginning of the file should look like this:

```isabelle
theory hello_world 
    imports Main
begin

THEORY BODY

end
```

`theory hello_world` declares the theory name and **must** exactly match the .thy filename. For example, if the file is called test.thy, then you would have `theory test`

`imports Main` tells it to import another theory; in this case that is Main.thy, which includes support for natural numbers, lists, and basic arithmetic

`begin` is the entry point into the theory body, while `end` is the end point of the theory body

In order to declare a constant and assign it a value, we use this general structure:

```isabelle
definition NAME :: TYPE where 
    "NAME = VALUE"
```

In our specific `hello_world.thy`, we will be assigning the value of "Hello World!" to a constant named "greeting" of the type "string".

```isabelle
definition greeting :: string where
    "greeting = ''Hello World!''"
```

In Isabelle, using the `definition` keyword introduce a constant, not a mutable variable. This means that the value of greeting will be fixed, equialent to "Hello World!" and cannot change within this theory.

Next we will declare a new theorem using the `lemma` command. Note that the **lemma** and **theorem** are intechangeable within Isabelle. The general structure of a lemma declaration is:

```isabelle
lemma LEMMA_NAME: "GOAL"
    by (PROOF_METHOD)
```

For our Hello World theory, we will be declaring a theorem called "hello_greeting" that will be proving that the value of "greeting" is indeed "Hello World!"

```isabelle
lemma hello_greeting: "greeting = ''Hello World!''"
    by (simp add: greeting_def)
```

The `simp` command invokes Isabelle's simplify method, which attempts to reduce the goal by using rewrite rules and known equalities. Using `add: greeting_def` tells simp to use the definition theorem greeting_def (automatically generated by the defition declaration of greeting) as an extra rewrite rule to simplify the goal.

The complete theory for hello_world.thy looks like this:

```isabelle
theory hello_world 
    imports Main
begin

definition greeting :: string where
    "greeting = ''Hello World!''"

lemma hello_greeting: "greeting = ''Hello World!''"
    by (simp add: greeting_def)

end
```

### 10.3.3 First Exercise
For the first exercise, we will be proving the associative and commutative properties of a custom `add` function in Isabelle. This exercise comes from Exercise 2.2 of [Concrete Semantics Exercises](http://www.concrete-semantics.org/Exercises/exercises.pdf)
<!-- i need to change this to a footnote or something that links to references at the end -->

WIP - i'm still porting over my code in isabelle and want to refine the explanations as well as make it easy to follow and understand

The custom add function is defined here:
```isabelle
fun add :: "nat ⇒ nat ⇒ nat" where
    "add 0 n = n" |
    "add (Suc m) n = Suc(add m n)"
```

We use 2 lemmas to prove each part of the exercise, namely:
```isabelle
lemma add_assoc: "add (add m n) p = add m (add n p)"
lemma add_comm: "add m n = add n m"
```

#### General Proof Structure for a Proof by Induction

Isabelle provides a general structure for how to approach and construct your proof. For this exercise, we will be using a proof by induction; first by proving a base case, and then by proving the sucessor case by using the induction hypothesis.

We start the proof by adding the command `proof(induction m)` after the `lemma` command. When we examine the output of this, we find that Isabele actually provides us with the overall goal, subgoals (such as the base case and successor cases), and the general proof outline

For example, for the associative property lemma, we get this:
```isabelle
goal (2 subgoals):
 1. add (add 0 n) p = add 0 (add n p)
 2. ⋀m. add (add m n) p = add m (add n p) ⟹ add (add (Suc m) n) p = add (Suc m) (add n p) 
Proof outline with cases:
  case 0
  then show ?case sorry
next
  case (Suc m)
  then show ?case sorry
qed
```

<!-- We first start off by proving the associative property: -->
#### Associative Property Proof

We first start off by proving the associative property of addition, and we do this by declaring the lemma and its goal:
```isabelle
lemma add_assoc: "add (add m n) p = add m (add n p)"
```
We then add the type of proof, which in this case will be a simple induction proof via the `proof` command:
```isabelle
proof (induction m) 
```
We then set the base case with:
```isabelle
  case 0
```
which will set `m = 0` as the base case, and then will update the goal to:
`add (add 0 n) p = add 0 (add n p)`

We then use:
```isabelle
  show ?case by simp
```

in order to simplify that new goal to:
`add n p = add n p`

Next, we perform the inductive step in order to prove that if the associative property holds for m, it must also hold for it's successor of  `Suc m`

We introduce the inductive step:
```isabelle
next
  case (Suc m)
```

This creates 2 things:
  - A goal of: `add (add (Suc m) n) p = add (Suc m) (add n p)`
  -	An induction hypothesis (Suc.IH) that assumes the property holds for m:
    `add (add m n) p = add m (add n p)`

<!-- We then use the recursive definition of add to expand both sides of the equation, and apply the induction hypothesis to simplify the inner equality. This shows that the associative property also holds for the successor case: -->
```isabelle
  show ?case by (simp add: Suc.IH)
```

Here, simp first expands both sides of the equation using the recursive definition
`add (Suc m) n = Suc (add m n)`
This reduces the goal to
`Suc (add (add m n) p) = Suc (add m (add n p))`
The induction hypothesis (Suc.IH) is then applied to replace
`add (add m n) p` with `add m (add n p)`,
making both sides identical.
The expression simplifies to Suc (...) = Suc (...) and completes the inductive step.

The full lemma proof for associativity is here:
```isabelle
lemma add_assoc: "add (add m n) p = add m (add n p)"
proof (induction m) 
  case 0
  show ?case by simp
next
  case (Suc m)
  show ?case by (simp add: Suc.IH)
qed
```


#### Communative Property Proof
Next, to prove the communative property, we will first prove 2 helper lemmas:
```isabelle
lemma add_0_right: "add m 0 = m"
lemma add_Suc_right: "add m (Suc n) = Suc (add m n)"
```

These proofs follow the same general format for induction:
```isabelle
lemma add_0_right: "add m 0 = m"
proof (induction m)
  case 0
  show ?case by simp
next
  case (Suc m)
  show ?case by (simp add: Suc.IH)
qed

lemma add_Suc_right: "add m (Suc n) = Suc (add m n)"
proof (induction m)
  case 0
  show ?case by simp
next
  case (Suc m)
  show ?case by (simp add: Suc.IH)
qed
```
<!-- This follows the same general format for inductive proofs
```isabelle
lemma add_0_right: "add m 0 = m"
proof(induction m)
  case 0

``` -->

<!-- Case 0 is the base case. In this instance, it means that we will set m = 0. Therefore, we will get `add 0 0 = 0` which is true.
  show ?case by simp
  (* Base: add 0 0 = 0 by add.simps(1) *)
next
  case (Suc m)
  (* 
  IH: add m 0 = m
  Goal: add (Suc m) 0 = Suc m.
  Expand the LHS with the recursive clause, then use the IH. 
  *)
  show ?case by (simp add: Suc.IH)
  (* Step: add (Suc m) 0 = Suc (add m 0) by add.simps(2), then = Suc m by IH *)
qed
``` -->

<!-- ##### add_Suc_rght Proof

```isabelle
lemma add_Suc_right: "add m (Suc n) = Suc (add m n)"
proof(induction m)
  case 0
  (* 
  Goal: add 0 (Suc n) = Suc (add 0 n).
  By add 0 x = x, both sides become Suc n.
  *)
  show ?case by simp
  (* Base: add 0 (Suc n) = Suc n and Suc (add 0 n) = Suc n *)
next
  case (Suc m)
  (*
  IH: add m (Suc n) = Suc (add m n)
  Goal: add (Suc m) (Suc n) = Suc (add (Suc m) n).
  Expand LHS with add.simps, then use IH, then fold once.
  *)
  show ?case by (simp add: Suc.IH)
  (* Step: add (Suc m) (Suc n) = Suc (add m (Suc n)) (def), then by IH = Suc (Suc (add m n)), 
  and simp recognizes that equals Suc (add (Suc m) n) via the def again *)
qed
``` -->

With the helper lemmas proven, we will use them to prove the commutative property

```isabelle
lemma add_comm: "add m n = add n m"
proof (induction m)
  case 0
  show ?case
    by (simp add: add_0_right)
next
  case (Suc m)
  show ?case
    by (simp add: Suc.IH add_Suc_right)
qed
```

where we use the add_0_right lemma in the base case and then the add_Suc_right lemma in the inductive step.

## 10.4 Introductory Examples {#sec0-10-4}


## 10.5 The Landscape of Tools {#sec0-10-5}


## 10.6 Algorithms {#sec0-10-6}


## 10.7 Benchmark and Competitions {#sec0-10-7}


## 10.8 Applications in Industry {#sec0-10-8}


## 10.9 Case Studies {#sec0-10-9}


## 10.10 History {#sec0-10-10}


## 10.11 Current Development, Research Challenges, Conferences and Workshops {#sec0-10-11}


## 10.12 References {#sec0-10-12}

- [Isabelle/HOL](https://isabelle.in.tum.de/)
- [Concrete Semantics](http://www.concrete-semantics.org/)
- [Concrete Semantics Exercises](http://www.concrete-semantics.org/Exercises/exercises.pdf)
- [Isabelle YouTube Tutorial by FDS 2020](https://www.youtube.com/@FDS-hs2uc/videos)
- [Syllogism Slides from Nate Moss](https://logic.berkeley.edu/colloquium/MossSlides.pdf)


## 10.13 Suggestions for Future Work {#sec0-10-13}

