

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>8. Higher-Order Logic with Isabelle &#8212; Logical Foundations of Computing</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"Set": ["{\\sf Set}", 0], "Qu": ["{\\Omega}", 0], "QuCat": ["{\\Omega\\text{-cat}}", 0], "One": ["{\\mathbb{1}}", 0], "yo": ["\u3088", 0], "bigsqcap": ["\\sqcap", 0]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'content/10-higher-order-logic';</script>
    <link rel="canonical" href="https://leap-at-chapman.github.io/CPSC-510-Logical-Foundations-of-Computing/content/10-higher-order-logic.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. Type Theory with Lean" href="11-dependent-types.html" />
    <link rel="prev" title="7. Hoare Logic with Dafny" href="9-hoare-logic.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="0-title.html">
  
  
  
  
  
  
    <p class="title logo__title">Logical Foundations of Computing</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="0-intro.html">The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="0-logic.html">Short Intro to Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="1-propositional-logic.html">Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="6-modal-logic.html">Modal Logic</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Logics and Tools</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="2-satsolving.html">1. SAT solving with MiniSat</a></li>
<li class="toctree-l1"><a class="reference internal" href="3-logic-programming.html">2. Logic Programming with Prolog</a></li>
<li class="toctree-l1"><a class="reference internal" href="4-constraint-solving.html">3. Constraints with MiniZinc</a></li>
<li class="toctree-l1"><a class="reference internal" href="5-smt-solving.html">4. SMT Solving and Z3</a></li>
<li class="toctree-l1"><a class="reference internal" href="7-temporal-logic.html">5. Temporal Logic with Spin</a></li>
<li class="toctree-l1"><a class="reference internal" href="8-epistemic-logic.html">6. Epistemic Logic with SMCDEL</a></li>
<li class="toctree-l1"><a class="reference internal" href="9-hoare-logic.html">7. Hoare Logic with Dafny</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">8. Higher-Order Logic with Isabelle</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-dependent-types.html">9. Type Theory with Lean</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="appendix-hoare-logic.html">Hoare Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix-syllogistic-logics.html">Syllogistic Logics in Isabelle</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Style Guide</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="how-to-cite.html">How to Cite References</a></li>
<li class="toctree-l1"><a class="reference internal" href="how-to-contribute.html">How to Contribute</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/LEAP-at-Chapman/CPSC-510-Logical-Foundations-of-Computing" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/LEAP-at-Chapman/CPSC-510-Logical-Foundations-of-Computing/issues/new?title=Issue%20on%20page%20%2Fcontent/10-higher-order-logic.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/content/10-higher-order-logic.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Higher-Order Logic with Isabelle</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#idea-and-introduction">8.1. Idea and Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-theory">8.2. Basic Theory</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-first-order-logic-to-higher-order-logic">8.2.1. From First-Order Logic to Higher-Order Logic</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-hol-type-system">8.2.2. The HOL Type System</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lambda-lambda-abstraction">8.2.3. Lambda (<span class="math notranslate nohighlight">\(\lambda\)</span>) Abstraction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logical-constants-in-hol">8.2.4. Logical Constants in HOL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deductive-core-of-hol">8.2.5. Deductive Core of HOL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tool-installation-first-example-first-exercise">8.3. Tool (Installation, First Example, First Exercise)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#installation">8.3.1. Installation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-solving-via-sledgehammer">8.3.2. Proof Solving via Sledgehammer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-example-add-function">8.3.3. First Example - Add Function</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-exercise-associativity-and-commutativity-of-add">8.3.4. First Exercise - Associativity and Commutativity of Add</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">8.3.5. First Exercise - Associativity and Commutativity of Add</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#intro-example-flattening-and-length-invariant">8.4. Intro Example - Flattening and Length Invariant</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">8.5. Intro Example - Flattening and Length Invariant</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#list-flattening">8.5.1. List Flattening</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#length-invariant">8.5.2. Length Invariant</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">8.5.3. List Flattening</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">8.5.4. Length Invariant</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-landscape-of-tools">8.6. The Landscape of Tools</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interactive-theorem-provers">8.6.1. Interactive Theorem Provers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#automated-theorem-prover">8.6.2. Automated Theorem Prover</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#programming-languages">8.6.3. Programming Languages</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms">8.7. Algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matching-and-unification">8.7.1. Matching and Unification</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simplification-rewriting">8.7.2. Simplification &amp; Rewriting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-search-and-external-automation">8.7.3. Proof Search and External Automation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#typical-use-cases">8.8. Typical Use Cases</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#benchmarks-and-competitions">8.9. Benchmarks and Competitions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-in-industry-and-academia">8.10. Applications in Industry and Academia</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#physical-addressing-on-real-hardware">8.10.1. Physical Addressing on Real Hardware</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#focus-stream-processing-components">8.10.2. FOCUS - Stream Processing Components</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isabil-verifying-in-correctness-of-binaries">8.10.3. IsaBIL - Verifying (In)Correctness of Binaries</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verlso-isolation-guarantees-of-database-transactions">8.10.4. Verlso - Isolation Guarantees of Database Transactions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ieee-754-floating-point-implementation-for-mdps">8.10.5. IEEE 754 Floating Point Implementation for MDPs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#autoformalization-with-large-language-models">8.10.6. Autoformalization with Large Language Models</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#case-study-autoformalization-with-llms">8.11. Case Study - Autoformalization with LLMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">8.12. Case Study - Autoformalization with LLMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#history">8.13. History</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#origins-of-higher-order-logic">8.13.1. Origins of Higher-Order Logic</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#development-of-isabelle-hol">8.13.2. Development of Isabelle/HOL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#current-events-within-isabelle-hol">8.14. Current Events within Isabelle/HOL</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#current-development">8.14.1. Current Development</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#research-challenges">8.14.2. Research Challenges</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conferences-and-workshops">8.14.3. Conferences and Workshops</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">8.15. References</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ebooks-and-textbooks">8.15.1. eBooks and Textbooks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">8.15.2. eBooks and Textbooks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#online-articles">8.15.3. Online Articles</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">8.15.4. Online Articles</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#research-papers">8.15.5. Research Papers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">8.15.6. Research Papers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#videos">8.15.7. Videos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">8.15.8. Videos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#miscellaneous">8.15.9. Miscellaneous</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#suggestions-for-future-work">8.16. Suggestions for Future Work</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#contributors">8.17. Contributors</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="higher-order-logic-with-isabelle">
<h1><span class="section-number">8. </span>Higher-Order Logic with Isabelle<a class="headerlink" href="#higher-order-logic-with-isabelle" title="Permalink to this heading">#</a></h1>
<p><em>Author: Spencer Au</em></p>
<section id="idea-and-introduction">
<h2><span class="section-number">8.1. </span>Idea and Introduction<a class="headerlink" href="#idea-and-introduction" title="Permalink to this heading">#</a></h2>
<p>Topics</p>
<ul class="simple">
<li><p>Higher-order logic foundations</p></li>
<li><p>Function types and quantification</p></li>
<li><p>Isabelle/HOL advanced features</p></li>
<li><p>Theorem proving strategies</p></li>
<li><p>Industrial theorem proving</p></li>
</ul>
<p>This chapter extends to higher-order logic in Isabelle/HOL, showing how to reason about functions as first-class objects and exploring the foundations of modern theorem proving.</p>
<p>Higher-order logic (HOL) extends the capabilities of first-order logic (FOL) by allowing quantifiers (such as <span class="math notranslate nohighlight">\( \forall x \)</span> and <span class="math notranslate nohighlight">\( \exists x \)</span>) to range over functions and predicates, not just individual elements. In addition, functions can be passed as arguments to other functions, returned as results, and manipulated just like any other data type. This enables more expressive statements about the properties of functions and their relationships.</p>
</section>
<section id="basic-theory">
<h2><span class="section-number">8.2. </span>Basic Theory<a class="headerlink" href="#basic-theory" title="Permalink to this heading">#</a></h2>
<section id="from-first-order-logic-to-higher-order-logic">
<h3><span class="section-number">8.2.1. </span>From First-Order Logic to Higher-Order Logic<a class="headerlink" href="#from-first-order-logic-to-higher-order-logic" title="Permalink to this heading">#</a></h3>
<p>First-order logic (FOL) restricts quantification to individual elements of a domain, without quantifying over predicates or functions. Second-order logic extends FOL by allowing quantification over relations, sets, and functions of that domain. Higher-order logic (HOL) generalizes this extension by allowing quantification over predicates and functions of arbitrary finite types, not just individuals or sets.<sup><a href="#SEP_HOL">[7]</a></sup>
First-order logic (FOL) restricts quantification to individual elements of a domain, without quantifying over predicates or functions. Second-order logic extends FOL by allowing quantification over relations, sets, and functions of that domain. Higher-order logic (HOL) generalizes this extension by allowing quantification over predicates and functions of arbitrary finite types, not just individuals or sets.<sup><a href="#SEP_HOL">[7]</a></sup></p>
</section>
<section id="the-hol-type-system">
<h3><span class="section-number">8.2.2. </span>The HOL Type System<a class="headerlink" href="#the-hol-type-system" title="Permalink to this heading">#</a></h3>
<p>In Isabelle/HOL, the underlying higher-order logic is built upon Church’s simple type theory<sup><a href="#Church_TypeTheory">[18]</a></sup>, which is a disciplined type system in which every term is assigned a type and compound types are formed using function type constructors. This simple type theory extends first-order logic by classifying individuals, predicates, and functions into an explicit hierarchy of types, enabling quantification over functions and predicates while avoiding the semantic paradoxes of untyped systems, such as an expression that may refer to itself in a problematic way. In HOL, the type system both guarantees well-formed expressions and organizes how functions of any finite type can be combined and applied.<sup><a href="#SEP_ChurchTypeTheory">[8]</a></sup> Church’s type theory is widely adopted in proof assistants implementing HOL, such as Isabelle/HOL, and offers a foundation for formalizing mathematics and computations.<sup><a href="#Isabelle_Logics">[2]</a></sup>
In Isabelle/HOL, the underlying higher-order logic is built upon Church’s simple type theory<sup><a href="#Church_TypeTheory">[18]</a></sup>, which is a disciplined type system in which every term is assigned a type and compound types are formed using function type constructors. This simple type theory extends first-order logic by classifying individuals, predicates, and functions into an explicit hierarchy of types, enabling quantification over functions and predicates while avoiding the semantic paradoxes of untyped systems, such as an expression that may refer to itself in a problematic way. In HOL, the type system both guarantees well-formed expressions and organizes how functions of any finite type can be combined and applied.<sup><a href="#SEP_ChurchTypeTheory">[8]</a></sup> Church’s type theory is widely adopted in proof assistants implementing HOL, such as Isabelle/HOL, and offers a foundation for formalizing mathematics and computations.<sup><a href="#Isabelle_Logics">[2]</a></sup></p>
<p><em>For further resources about type theory, SEP provides an excellent article on Type Theory<sup><a href="#SEP_TypeTheory">[9]</a></sup>. There is also a solid YouTube video for those that would prefer a different medium.<sup><a href="#TypeTheory_Youtube">[32]</a></sup></em>
<em>For further resources about type theory, SEP provides an excellent article on Type Theory<sup><a href="#SEP_TypeTheory">[9]</a></sup>. There is also a solid YouTube video for those that would prefer a different medium.<sup><a href="#TypeTheory_Youtube">[32]</a></sup></em></p>
</section>
<section id="lambda-lambda-abstraction">
<h3><span class="section-number">8.2.3. </span>Lambda (<span class="math notranslate nohighlight">\(\lambda\)</span>) Abstraction<a class="headerlink" href="#lambda-lambda-abstraction" title="Permalink to this heading">#</a></h3>
<p>In higher-order logic, <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction provides a formal way to define anonymous functions by binding variables in expressions. We write this as <span class="math notranslate nohighlight">\(\lambda x.\; t\)</span>, where x is a parameter and t is the body of the function. A <span class="math notranslate nohighlight">\(\lambda\)</span>-term defines a function by binding a variable in an expression, and <span class="math notranslate nohighlight">\(\beta\)</span>-reduction is the rule that implements function application. Basically, when you apply a <span class="math notranslate nohighlight">\(\lambda\)</span>-term to an argument, you substitute that argument for the bound variable in the function body. For example, the abstraction <span class="math notranslate nohighlight">\(\lambda x. \; x * x\)</span> represents the square function, and applying it to an arbitrary number <span class="math notranslate nohighlight">\(a\)</span> yields <span class="math notranslate nohighlight">\(a * a\)</span> by replacing <span class="math notranslate nohighlight">\(x\)</span> with <span class="math notranslate nohighlight">\(a\)</span>.<sup><a href="#Kurz_LambdaSemantics">[10]</a></sup> <sup><a href="#Kurz_LambdaSyntax">[11]</a></sup>
In higher-order logic, <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction provides a formal way to define anonymous functions by binding variables in expressions. We write this as <span class="math notranslate nohighlight">\(\lambda x.\; t\)</span>, where x is a parameter and t is the body of the function. A <span class="math notranslate nohighlight">\(\lambda\)</span>-term defines a function by binding a variable in an expression, and <span class="math notranslate nohighlight">\(\beta\)</span>-reduction is the rule that implements function application. Basically, when you apply a <span class="math notranslate nohighlight">\(\lambda\)</span>-term to an argument, you substitute that argument for the bound variable in the function body. For example, the abstraction <span class="math notranslate nohighlight">\(\lambda x. \; x * x\)</span> represents the square function, and applying it to an arbitrary number <span class="math notranslate nohighlight">\(a\)</span> yields <span class="math notranslate nohighlight">\(a * a\)</span> by replacing <span class="math notranslate nohighlight">\(x\)</span> with <span class="math notranslate nohighlight">\(a\)</span>.<sup><a href="#Kurz_LambdaSemantics">[10]</a></sup> <sup><a href="#Kurz_LambdaSyntax">[11]</a></sup></p>
<p>In Isabelle/HOL, <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction is part of the underlying simply typed <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus, where terms consist of variables, constants, applications, and abstractions. Applying a <span class="math notranslate nohighlight">\(\lambda\)</span>-term to an argument substitutes the argument for the bound variable in the body, and Isabelle treats the original application and its <span class="math notranslate nohighlight">\(\beta\)</span>-reduced form as equivalent. This mechanism makes functions first-class citizens in HOL, supports the construction of higher-order functions, and enables logical constructs to be expressed uniformly.<sup><a href="#Isabelle_Logics">[2]</a></sup>
In Isabelle/HOL, <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction is part of the underlying simply typed <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus, where terms consist of variables, constants, applications, and abstractions. Applying a <span class="math notranslate nohighlight">\(\lambda\)</span>-term to an argument substitutes the argument for the bound variable in the body, and Isabelle treats the original application and its <span class="math notranslate nohighlight">\(\beta\)</span>-reduced form as equivalent. This mechanism makes functions first-class citizens in HOL, supports the construction of higher-order functions, and enables logical constructs to be expressed uniformly.<sup><a href="#Isabelle_Logics">[2]</a></sup></p>
<p><em>For supplementary resources about <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction and <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus, SEP again provides some excellent articles.<sup><a href="#Stanford_LambdaCalc_TypeTheory">[12]</a></sup> <sup><a href="#SEP_LambdaCalc">[13]</a></sup> There are also easy to grasp YouTube videos by LigerLearn.<sup><a href="#LigerLearn_LambdaPrimer">[30]</a></sup> <sup><a href="#LigerLearn_LambdaEval">[31]</a></sup></em>
<em>For supplementary resources about <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction and <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus, SEP again provides some excellent articles.<sup><a href="#Stanford_LambdaCalc_TypeTheory">[12]</a></sup> <sup><a href="#SEP_LambdaCalc">[13]</a></sup> There are also easy to grasp YouTube videos by LigerLearn.<sup><a href="#LigerLearn_LambdaPrimer">[30]</a></sup> <sup><a href="#LigerLearn_LambdaEval">[31]</a></sup></em></p>
</section>
<section id="logical-constants-in-hol">
<h3><span class="section-number">8.2.4. </span>Logical Constants in HOL<a class="headerlink" href="#logical-constants-in-hol" title="Permalink to this heading">#</a></h3>
<p>In higher-order logic, the logical constants are the primitive symbols that express the core logical operations and quantification. They include propositional connectives such as:</p>
<ul class="simple">
<li><p>Conjunction (<span class="math notranslate nohighlight">\(\land\)</span>)</p></li>
<li><p>Disjunction (<span class="math notranslate nohighlight">\(\lor\)</span>)</p></li>
<li><p>Implication (<span class="math notranslate nohighlight">\(\to\)</span>)</p></li>
<li><p>Negation (<span class="math notranslate nohighlight">\(\neg\)</span>)</p></li>
<li><p>Equality (<span class="math notranslate nohighlight">\(=\)</span>)</p></li>
</ul>
<p>as well as quantifiers like:</p>
<ul class="simple">
<li><p>Universal (<span class="math notranslate nohighlight">\(\forall\)</span>)</p></li>
<li><p>Existential (<span class="math notranslate nohighlight">\(\exists\)</span>)</p></li>
</ul>
<p>which operate over objects of any type. In Isabelle/HOL, the full syntax of terms and constants is defined by the grammar of HOL and is treated uniformly alongside function application and <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction. This vocabulary is the basis on which more complex formulas are built and manipulated in proof development.<sup><a href="#Isabelle_Logics">[2]</a></sup>
which operate over objects of any type. In Isabelle/HOL, the full syntax of terms and constants is defined by the grammar of HOL and is treated uniformly alongside function application and <span class="math notranslate nohighlight">\(\lambda\)</span>-abstraction. This vocabulary is the basis on which more complex formulas are built and manipulated in proof development.<sup><a href="#Isabelle_Logics">[2]</a></sup></p>
</section>
<section id="deductive-core-of-hol">
<h3><span class="section-number">8.2.5. </span>Deductive Core of HOL<a class="headerlink" href="#deductive-core-of-hol" title="Permalink to this heading">#</a></h3>
<p>The deductive core of higher-order logic consists of the fundamental inference rules for logical connectives, quantifiers, and equality, including the basic introduction and elimination rules that govern valid reasoning in HOL. In Isabelle/HOL, these primitive rules form the logic’s core inference system, and every derived theorem is justified by a sequence of such sound rule applications. Higher level proof methods and tactics ultimately based on these basic rules make structured proofs possible in practice. Concrete presentations of these inference rules and how they are used in proofs can be found in the Isabelle/HOL Proof Assistant Manual.<sup><a href="#Isabelle/HOL_ProofAssistant">[3]</a></sup>
The deductive core of higher-order logic consists of the fundamental inference rules for logical connectives, quantifiers, and equality, including the basic introduction and elimination rules that govern valid reasoning in HOL. In Isabelle/HOL, these primitive rules form the logic’s core inference system, and every derived theorem is justified by a sequence of such sound rule applications. Higher level proof methods and tactics ultimately based on these basic rules make structured proofs possible in practice. Concrete presentations of these inference rules and how they are used in proofs can be found in the Isabelle/HOL Proof Assistant Manual.<sup><a href="#Isabelle/HOL_ProofAssistant">[3]</a></sup></p>
</section>
</section>
<section id="tool-installation-first-example-first-exercise">
<h2><span class="section-number">8.3. </span>Tool (Installation, First Example, First Exercise)<a class="headerlink" href="#tool-installation-first-example-first-exercise" title="Permalink to this heading">#</a></h2>
<section id="installation">
<h3><span class="section-number">8.3.1. </span>Installation<a class="headerlink" href="#installation" title="Permalink to this heading">#</a></h3>
<p><a class="reference external" href="https://isabelle.in.tum.de/">Installation Link for Isabelle</a></p>
<p>Isabelle processes the theory document incrementally in the background, meaning that there is no additional “compile” or “run” step. As you type in lines and commands, the background system will check them and automatically update the proof state and any relevant error reports. Just go line by line, or command by command in order to check the related output.</p>
<p>Isabelle uses *.thy (theory) files, and the general structure of the theory files is like this:</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="k">theory</span><span class="w"> </span><span class="n">THEORY_NAME</span>
<span class="w">    </span><span class="kp">imports</span><span class="w"> </span><span class="n">OTHER_THEORIES</span>

<span class="k">begin</span>

<span class="n">THEORY_BODY</span>

<span class="k">end</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">theory</span> <span class="pre">THEORY_NAME</span></code> declares the theory name and <strong>must</strong> exactly match the .thy filename. For example, if the file is called test.thy, then you would have <code class="docutils literal notranslate"><span class="pre">theory</span> <span class="pre">test</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">imports</span> <span class="pre">OTHER_THEORIES</span></code> tells it to import another theory; for example, one popular theory to import is Main.thy, which includes support for natural numbers, lists, and basic arithmetic</p>
<p><code class="docutils literal notranslate"><span class="pre">begin</span></code> is the entry point into the theory body, while <code class="docutils literal notranslate"><span class="pre">end</span></code> is the end point of the theory body</p>
<p>More detailed instructions on setup and initial use can be found in Chapters 1 and 2.1.2 of <em>Concrete Semantics</em><sup><a href="#ConcreteSemantics">[1]</a></sup></p>
</section>
<section id="proof-solving-via-sledgehammer">
<h3><span class="section-number">8.3.2. </span>Proof Solving via Sledgehammer<a class="headerlink" href="#proof-solving-via-sledgehammer" title="Permalink to this heading">#</a></h3>
<p>Sledgehammer is an automated theorem prover orchestrator. It dispatches proof obligations to external provers such as Vampire via command line and returns candidate proofs that can be directly applied. Basically, it find proofs by “hammering away” at different sub-goals that would typically be tedious to construct manually. In the Isabelle GUI, Sledgehammer can be accessed by clicking on the <em>sledgehammer</em> tab on the bottom left corner of the application: select the target sub-goal, invoke Sledgehammer via apply, and then apply a suggested proof if found. Although <em>Concrete Semantics 4.3.1</em><sup><a href="#ConcreteSemantics">[1]</a></sup> introduces the basic sledgehammer command, the GUI method is generally more convenient. The official Isabelle Sledgehammer documentation page<sup><a href="#Isabelle_Sledgehammer">[35]</a></sup> provides further detail.
Sledgehammer is an automated theorem prover orchestrator. It dispatches proof obligations to external provers such as Vampire via command line and returns candidate proofs that can be directly applied. Basically, it find proofs by “hammering away” at different sub-goals that would typically be tedious to construct manually. In the Isabelle GUI, Sledgehammer can be accessed by clicking on the <em>sledgehammer</em> tab on the bottom left corner of the application: select the target sub-goal, invoke Sledgehammer via apply, and then apply a suggested proof if found. Although <em>Concrete Semantics 4.3.1</em><sup><a href="#ConcreteSemantics">[1]</a></sup> introduces the basic sledgehammer command, the GUI method is generally more convenient. The official Isabelle Sledgehammer documentation page<sup><a href="#Isabelle_Sledgehammer">[35]</a></sup> provides further detail.</p>
</section>
<section id="first-example-add-function">
<h3><span class="section-number">8.3.3. </span>First Example - Add Function<a class="headerlink" href="#first-example-add-function" title="Permalink to this heading">#</a></h3>
<p>For the first example, the goal will be to implement recursive addition via a function called “add”. The general form should be:</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;nat ⇒ nat ⇒ nat&quot;</span><span class="w"> </span><span class="kp">where</span>
<span class="w">  </span><span class="s">&quot;base case&quot;</span>
<span class="w">  </span><span class="s">&quot;recursive case&quot;</span>
<span class="w">  </span><span class="s">&quot;base case&quot;</span>
<span class="w">  </span><span class="s">&quot;recursive case&quot;</span>
</pre></div>
</div>
<p>where two natural numbers are added, and the result is a natural number that is the sum of the two input numbers. For example, <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">m</span> <span class="pre">n</span></code> should return the sum of m and n.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;nat ⇒ nat ⇒ nat&quot;</span><span class="w"> </span><span class="kp">where</span>
<span class="w">  </span><span class="s">&quot;add 0 n = n&quot;</span><span class="w"> </span><span class="o">|</span>
<span class="w">  </span><span class="s">&quot;add (Suc m) n = Suc (add m n)&quot;</span><span class="w"> </span>
</pre></div>
</div>
</div>
</details><p>For a detailed explanation, <a class="reference internal" href="assets-10/8.3_exercises.html"><span class="doc std std-doc">See Section 8.3.2 Exercises</span></a></p>
</section>
<section id="first-exercise-associativity-and-commutativity-of-add">
<h3><span class="section-number">8.3.4. </span>First Exercise - Associativity and Commutativity of Add<a class="headerlink" href="#first-exercise-associativity-and-commutativity-of-add" title="Permalink to this heading">#</a></h3>
</section>
<section id="id1">
<h3><span class="section-number">8.3.5. </span>First Exercise - Associativity and Commutativity of Add<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<p>For the first exercise, we will be proving the associative and commutative properties of a custom <code class="docutils literal notranslate"><span class="pre">add</span></code> function in Isabelle. This exercise comes from Exercise 2.2 of <a class="reference external" href="http://www.concrete-semantics.org/Exercises/exercises.pdf">Concrete Semantics Exercises</a></p>
<p>The custom add function is defined here:</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;nat =&gt; nat =&gt; nat&quot;</span><span class="w"> </span><span class="kp">where</span>
<span class="w">  </span><span class="s">&quot;add 0 n = n&quot;</span><span class="w"> </span><span class="o">|</span>
<span class="w">  </span><span class="s">&quot;add (Suc m) n = Suc(add m n)&quot;</span>
<span class="w">  </span><span class="s">&quot;add 0 n = n&quot;</span><span class="w"> </span><span class="o">|</span>
<span class="w">  </span><span class="s">&quot;add (Suc m) n = Suc(add m n)&quot;</span>
</pre></div>
</div>
</div>
</details><p>We use 2 lemmas to prove each part of the exercise, namely:</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">add_assoc</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add (add m n) p = add m (add n p)&quot;</span>
<span class="kn">lemma</span><span class="w"> </span><span class="n">add_comm</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add m n = add n m&quot;</span>
</pre></div>
</div>
<p>The full lemma proof for associativity is here:</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">add_assoc</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add (add m n) p = add m (add n p)&quot;</span>
<span class="k">proof</span><span class="w"> </span><span class="o">(</span><span class="n">induction</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">0</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
<span class="k">next</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">(</span><span class="n">Suc</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">simp</span><span class="w"> </span><span class="n">add</span><span class="o">:</span><span class="w"> </span><span class="n">Suc.IH</span><span class="o">)</span>
<span class="k">qed</span>
</pre></div>
</div>
</div>
</details><p>For a detailed explanation, <span class="xref myst">See Section 8.3.3 Associative Property</span></p>
<p>Next, to prove the commutative property, we will first prove 2 helper lemmas:
Next, to prove the commutative property, we will first prove 2 helper lemmas:</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">add_0_right</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add m 0 = m&quot;</span>
<span class="kn">lemma</span><span class="w"> </span><span class="n">add_Suc_right</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add m (Suc n) = Suc (add m n)&quot;</span>
</pre></div>
</div>
<p>The helper lemma proofs for commutativity
The helper lemma proofs for commutativity</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">add_0_right</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add m 0 = m&quot;</span>
<span class="k">proof</span><span class="w"> </span><span class="o">(</span><span class="n">induction</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">0</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
<span class="k">next</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">(</span><span class="n">Suc</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">simp</span><span class="w"> </span><span class="n">add</span><span class="o">:</span><span class="w"> </span><span class="n">Suc.IH</span><span class="o">)</span>
<span class="k">qed</span>

<span class="kn">lemma</span><span class="w"> </span><span class="n">add_Suc_right</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add m (Suc n) = Suc (add m n)&quot;</span>
<span class="k">proof</span><span class="w"> </span><span class="o">(</span><span class="n">induction</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">0</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
<span class="k">next</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">(</span><span class="n">Suc</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">simp</span><span class="w"> </span><span class="n">add</span><span class="o">:</span><span class="w"> </span><span class="n">Suc.IH</span><span class="o">)</span>
<span class="k">qed</span>
</pre></div>
</div>
</div>
</details><p>With the helper lemmas proven, we will use them to prove the commutative property</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">add_comm</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;add m n = add n m&quot;</span>
<span class="k">proof</span><span class="w"> </span><span class="o">(</span><span class="n">induction</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">0</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span>
<span class="w">    </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">simp</span><span class="w"> </span><span class="n">add</span><span class="o">:</span><span class="w"> </span><span class="n">add_0_right</span><span class="o">)</span>
<span class="k">next</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">(</span><span class="n">Suc</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="w">  </span><span class="k">show</span><span class="w"> </span><span class="o">?</span><span class="k">case</span>
<span class="w">    </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">simp</span><span class="w"> </span><span class="n">add</span><span class="o">:</span><span class="w"> </span><span class="n">Suc.IH</span><span class="w"> </span><span class="n">add_Suc_right</span><span class="o">)</span>
<span class="k">qed</span>
</pre></div>
</div>
</div>
</details><p>For a detailed explanation, <span class="xref myst">See Section 8.3.3 Commutative Property</span>
For a detailed explanation, <span class="xref myst">See Section 8.3.3 Commutative Property</span></p>
<p><em>The Isabelle .thy file for this exercise are located <a class="reference download internal" download="" href="../_downloads/d624d383f05f5525cbb5b2a3316e16aa/exercise_2_2.thy"><span class="xref download myst">here</span></a></em></p>
<p><em>This form is an Isar style proof. The following example will be an older style tactic based proof.</em></p>
</section>
</section>
<section id="intro-example-flattening-and-length-invariant">
<h2><span class="section-number">8.4. </span>Intro Example - Flattening and Length Invariant<a class="headerlink" href="#intro-example-flattening-and-length-invariant" title="Permalink to this heading">#</a></h2>
<p><em>The Isabelle .thy file for this exercise are located <a class="reference download internal" download="" href="../_downloads/d624d383f05f5525cbb5b2a3316e16aa/exercise_2_2.thy"><span class="xref download myst">here</span></a></em></p>
<p><em>This form is an Isar style proof. The following example will be an older style tactic based proof.</em></p>
</section>
<section id="id2">
<h2><span class="section-number">8.5. </span>Intro Example - Flattening and Length Invariant<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h2>
<!-- show something interesting about tool, logic, etc and can be digested and understood with minimum experience -->
<p>There is an introduction exercise to syllogistic logic<sup><a href="#MossSyllogism">[34]</a></sup> in Isabelle by Alexander Kurz linked <a class="reference internal" href="appendix-syllogistic-logics.html"><span class="doc std std-doc">here</span></a>.</p>
<p>The List Flattening and Length Preservation exercise is adjusted from <a class="reference external" href="https://isabelle.in.tum.de/exercises/lists/sum/sol.pdf">this exercise</a>. First try the exercise yourself, and if stuck, reference the document linked.</p>
<section id="list-flattening">
<h3><span class="section-number">8.5.1. </span>List Flattening<a class="headerlink" href="#list-flattening" title="Permalink to this heading">#</a></h3>
<p>Define a recursive function <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">flatten</span> <span class="pre">::</span> <span class="pre">'a</span> <span class="pre">list</span> <span class="pre">list</span> <span class="pre">=&gt;</span> <span class="pre">'a</span> <span class="pre">list</span></code> that takes a list of lists as input, flattens it, and returns that flattened list. Flattening is simply turning a multi-dimensional list into a single list by concatenating inner lists. For example, if we have <span class="math notranslate nohighlight">\([[1,2], [3,4], [5]]\)</span>, then flattening would yield <span class="math notranslate nohighlight">\([1,2,3,4,5]\)</span>.</p>
<p>For the base case, simply check if the input list is empty, and if so, return an empty list. For the recursive case, match a non-empty list with (xs # xss) and concatenate xs (using &#64;) with the result of flattening xss.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span><span class="w"> </span><span class="n">flatten</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;&#39;a list list =&gt; &#39;a list&quot;</span><span class="w"> </span><span class="kp">where</span>
<span class="w">  </span><span class="s">&quot;flatten [] = []&quot;</span>
<span class="w">  </span><span class="o">|</span><span class="s">&quot;flatten (xs # xss) = xs @ flatten xss&quot;</span>
</pre></div>
</div>
</div>
</details><p>Use a quick lemma with simp to confirm that the function works:</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="s">&quot;flatten [[1::nat, 2], [3,4], [5,6], [7]] = [1,2,3,4,5,6,7]&quot;</span>
<span class="w">  </span><span class="kp">apply</span><span class="w"> </span><span class="n">simp</span>
<span class="w">  </span><span class="k">done</span>
</pre></div>
</div>
<p>If there are no errors, then the flatten function is implemented correctly.</p>
</section>
<section id="length-invariant">
<h3><span class="section-number">8.5.2. </span>Length Invariant<a class="headerlink" href="#length-invariant" title="Permalink to this heading">#</a></h3>
<p>The next step is to prove that the flatten function implemented is <em>length invariant</em>, meaning that the operation doesn’t create or lose elements, but instead only performs simple concatenation.</p>
<p>Define a lemma called <code class="docutils literal notranslate"><span class="pre">lemma</span> <span class="pre">length_flatten:</span></code>, and check that for all xss, the length of flatten(xss) equals the sum of the lengths of the lists inside xss using.</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">length_flatten</span><span class="o">:</span>
<span class="w">  </span><span class="s">&quot;length (flatten xss) = sum_list (map length xss)&quot;</span>
</pre></div>
</div>
<p>Since this proof is relatively simple, a tactic based approach would be ideal. Set up the tactic based proof by induction by using <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">(induct</span> <span class="pre">xss)</span></code></p>
<p>There should now be 2 subgoals, and from there, simply leverage the Sledgehammer tool to solve proof obligations.</p>
<p>The full proof is here. Isabelle will recognize the lemma as a theorem when all proof obligations have been satisfied.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">length_flatten</span><span class="o">:</span>
<span class="w">  </span><span class="s">&quot;length (flatten xss) = sum_list (map length xss)&quot;</span>
<span class="w">  </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="n">induct</span><span class="w"> </span><span class="n">xss</span><span class="o">)</span>
<span class="w">    </span><span class="kp">apply</span><span class="w"> </span><span class="n">simp</span>
<span class="w">  </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
</pre></div>
</div>
</div>
</details><p><em>The Isabelle .thy file for this exercise are located <a class="reference download internal" download="" href="../_downloads/dfb482bb4e25cd32c73c48320bb8208f/list_flatten.thy"><span class="xref download myst">here</span></a></em>
There is an introduction exercise to syllogistic logic<sup><a href="#MossSyllogism">[34]</a></sup> in Isabelle by Alexander Kurz linked <a class="reference internal" href="appendix-syllogistic-logics.html"><span class="doc std std-doc">here</span></a>.</p>
<p>The List Flattening and Length Preservation exercise is adjusted from <a class="reference external" href="https://isabelle.in.tum.de/exercises/lists/sum/sol.pdf">this exercise</a>. First try the exercise yourself, and if stuck, reference the document linked.</p>
</section>
<section id="id3">
<h3><span class="section-number">8.5.3. </span>List Flattening<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h3>
<p>Define a recursive function <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">flatten</span> <span class="pre">::</span> <span class="pre">'a</span> <span class="pre">list</span> <span class="pre">list</span> <span class="pre">=&gt;</span> <span class="pre">'a</span> <span class="pre">list</span></code> that takes a list of lists as input, flattens it, and returns that flattened list. Flattening is simply turning a multi-dimensional list into a single list by concatenating inner lists. For example, if we have <span class="math notranslate nohighlight">\([[1,2], [3,4], [5]]\)</span>, then flattening would yield <span class="math notranslate nohighlight">\([1,2,3,4,5]\)</span>.</p>
<p>For the base case, simply check if the input list is empty, and if so, return an empty list. For the recursive case, match a non-empty list with (xs # xss) and concatenate xs (using &#64;) with the result of flattening xss.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span><span class="w"> </span><span class="n">flatten</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;&#39;a list list =&gt; &#39;a list&quot;</span><span class="w"> </span><span class="kp">where</span>
<span class="w">  </span><span class="s">&quot;flatten [] = []&quot;</span>
<span class="w">  </span><span class="o">|</span><span class="s">&quot;flatten (xs # xss) = xs @ flatten xss&quot;</span>
</pre></div>
</div>
</div>
</details><p>Use a quick lemma with simp to confirm that the function works:</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="s">&quot;flatten [[1::nat, 2], [3,4], [5,6], [7]] = [1,2,3,4,5,6,7]&quot;</span>
<span class="w">  </span><span class="kp">apply</span><span class="w"> </span><span class="n">simp</span>
<span class="w">  </span><span class="k">done</span>
</pre></div>
</div>
<p>If there are no errors, then the flatten function is implemented correctly.</p>
</section>
<section id="id4">
<h3><span class="section-number">8.5.4. </span>Length Invariant<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<p>The next step is to prove that the flatten function implemented is <em>length invariant</em>, meaning that the operation doesn’t create or lose elements, but instead only performs simple concatenation.</p>
<p>Define a lemma called <code class="docutils literal notranslate"><span class="pre">lemma</span> <span class="pre">length_flatten:</span></code>, and check that for all xss, the length of flatten(xss) equals the sum of the lengths of the lists inside xss using.</p>
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">length_flatten</span><span class="o">:</span>
<span class="w">  </span><span class="s">&quot;length (flatten xss) = sum_list (map length xss)&quot;</span>
</pre></div>
</div>
<p>Since this proof is relatively simple, a tactic based approach would be ideal. Set up the tactic based proof by induction by using <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">(induct</span> <span class="pre">xss)</span></code></p>
<p>There should now be 2 subgoals, and from there, simply leverage the Sledgehammer tool to solve proof obligations.</p>
<p>The full proof is here. Isabelle will recognize the lemma as a theorem when all proof obligations have been satisfied.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Show Answer<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<div class="highlight-isabelle notranslate"><div class="highlight"><pre><span></span><span class="kn">lemma</span><span class="w"> </span><span class="n">length_flatten</span><span class="o">:</span>
<span class="w">  </span><span class="s">&quot;length (flatten xss) = sum_list (map length xss)&quot;</span>
<span class="w">  </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="n">induct</span><span class="w"> </span><span class="n">xss</span><span class="o">)</span>
<span class="w">    </span><span class="kp">apply</span><span class="w"> </span><span class="n">simp</span>
<span class="w">  </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
</pre></div>
</div>
</div>
</details><p><em>The Isabelle .thy file for this exercise are located <a class="reference download internal" download="" href="../_downloads/dfb482bb4e25cd32c73c48320bb8208f/list_flatten.thy"><span class="xref download myst">here</span></a></em></p>
</section>
</section>
<section id="the-landscape-of-tools">
<h2><span class="section-number">8.6. </span>The Landscape of Tools<a class="headerlink" href="#the-landscape-of-tools" title="Permalink to this heading">#</a></h2>
<section id="interactive-theorem-provers">
<h3><span class="section-number">8.6.1. </span>Interactive Theorem Provers<a class="headerlink" href="#interactive-theorem-provers" title="Permalink to this heading">#</a></h3>
<p><strong>HOL4</strong> is part of the “HOL” family of interactive theorem provers, using classical higher-order logic and following the LCF approach to ensure soundness. Developed by Michael J. C. Gordon, the system is implemented in ML, and is a direct descendent of the original HOL88 system. Because HOL4 shares the same underlying logic as Isabelle/HOL, many theories and proof patterns are generally portable between the two tools.</p>
<p><strong>Rocq</strong> (formerly Coq) is an interactive theorem prover based on the Calculus of Inductive Constructions (CIC), which is dependently typed <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus that extends the Calculus of Constructions with inductive types. This extension allow propositions to be represented as types and proofs as programs, enabling highly expressive specifications. Rocq is mainly implemented in OCaml with some C, and it’s dependent type theory allows it to have greater expressive power over Isabelle/HOL.
<strong>Rocq</strong> (formerly Coq) is an interactive theorem prover based on the Calculus of Inductive Constructions (CIC), which is dependently typed <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus that extends the Calculus of Constructions with inductive types. This extension allow propositions to be represented as types and proofs as programs, enabling highly expressive specifications. Rocq is mainly implemented in OCaml with some C, and it’s dependent type theory allows it to have greater expressive power over Isabelle/HOL.</p>
<p><strong>Lean (4)</strong> is another proof assistant that follows a similar but more modern variant of dependent type theory. Like Rocq, Learn also extends the Calculus of Constructions with inductive types. Lean 4 in particular is mostly implemented in Lean (with some C++), and can have its Lean theorem prover produce C code. Like Rocq, Lean 4’s dependent type theory also supports greater expressive power compared to Isabelle/HOL.</p>
</section>
<section id="automated-theorem-prover">
<h3><span class="section-number">8.6.2. </span>Automated Theorem Prover<a class="headerlink" href="#automated-theorem-prover" title="Permalink to this heading">#</a></h3>
<p><strong>Leo III</strong> is an automated theorem prover for classical higher-order logic that supports all common TPTP input dialects and is based on paramodulation calculus with ordering constraints for reasoning. Leo III is written in Scala and runs on the JVM (Java Virtual Machine). Compared with ITPs (interactive theorem provers) like Isabelle/HOL, Leo III trades human-guided proof structuring and granular control for full automation, allowing it to rapidly discharge proof obligations.<sup><a href="#LeoIII">[28]</a></sup>
<strong>Leo III</strong> is an automated theorem prover for classical higher-order logic that supports all common TPTP input dialects and is based on paramodulation calculus with ordering constraints for reasoning. Leo III is written in Scala and runs on the JVM (Java Virtual Machine). Compared with ITPs (interactive theorem provers) like Isabelle/HOL, Leo III trades human-guided proof structuring and granular control for full automation, allowing it to rapidly discharge proof obligations.<sup><a href="#LeoIII">[28]</a></sup></p>
<p><strong>Satallax</strong> is another automated theorem prover for classical higher-order logic and is based on Church’s simple type theory with extensionality and choice operators. It is implemented in OCaml and uses the SAT solver MiniSat for its proof search. Basically, Satallax generates propositional clauses corresponding to the rules of a complete tableau calculus and calls MiniSat periodically to test the satisfiability of these clauses.<sup><a href="#Satallax">[16]</a></sup></p>
</section>
<section id="programming-languages">
<h3><span class="section-number">8.6.3. </span>Programming Languages<a class="headerlink" href="#programming-languages" title="Permalink to this heading">#</a></h3>
<p><strong>F*</strong> is a dependently typed programming language that integrates program development with proof construction in a single system. It’s type system lets you encode precise specifications and it uses SMT solvers to automatically discharge proof obligations while still supporting interactive proof guidance when necessary, similar to Isabelle and its Sledgehammer tool. More information about F* with a web-based tutorial can be found <a class="reference external" href="https://fstar-lang.org/tutorial/">here</a>.</p>
</section>
</section>
<section id="algorithms">
<h2><span class="section-number">8.7. </span>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this heading">#</a></h2>
<p>WIP</p>
<section id="matching-and-unification">
<h3><span class="section-number">8.7.1. </span>Matching and Unification<a class="headerlink" href="#matching-and-unification" title="Permalink to this heading">#</a></h3>
<!-- This is the engine that lets the system fit rules to goals.
Unification (especially first-order and higher-order patterns) is the key algorithm that determines how variables in rules or lemmas can be instantiated to match the current proof goal or subgoal. In Isabelle/HOL, unification drives rule application, tactic behavior, and many automation steps, linking the declarative inference rules to concrete proof steps.

What to cover
	•	First-order unification basics
	•	Pattern unification in HOL context
	•	How unification enables lemma instantiation and rule application

Why this matters
	•	It’s the bridge from abstract inference rules to concrete uses in proofs. -->
</section>
<section id="simplification-rewriting">
<h3><span class="section-number">8.7.2. </span>Simplification &amp; Rewriting<a class="headerlink" href="#simplification-rewriting" title="Permalink to this heading">#</a></h3>
<!-- This is the core term-engine that most automated tactics rely on.

The simplifier in Isabelle/HOL repeatedly applies rewrite rules — typically equational theorems — to simplify terms. This involves heuristics such as term ordering and conditional rewriting, which make it efficient and prevent infinite rewriting loops. The simplifier is used by tactics like simp and underpins many other automatic proof methods.

What to cover
	•	Term rewriting as a mechanical simplification algorithm
	•	Conditional rewriting and simplification strategies
	•	How this intersects with automation (simp, auto, etc.) -->
</section>
<section id="proof-search-and-external-automation">
<h3><span class="section-number">8.7.3. </span>Proof Search and External Automation<a class="headerlink" href="#proof-search-and-external-automation" title="Permalink to this heading">#</a></h3>
<!-- This covers the practical automation layer that makes Isabelle powerful in real use.

Isabelle/HOL provides algorithms that integrate internal proof search with powerful external solvers. A standout example is Sledgehammer, which heuristically selects relevant facts from the context, encodes goals for external automatic theorem provers (ATPs) and SMT solvers, and reconstructs validated proofs back inside Isabelle so that trust remains intact.  ￼

This class also includes:
	•	Invocation and reconstruction of external ATP/SMT proofs
	•	Built-in general search strategies (e.g., resolution-style search)
	•	Tactics like auto, blast, and the Metis integration that systematically explore proof alternatives

What to cover
	•	Idea of heuristically guided search
	•	Integration with external solvers and reconstruction
	•	How this differs from the pure logic core -->
</section>
</section>
<section id="typical-use-cases">
<h2><span class="section-number">8.8. </span>Typical Use Cases<a class="headerlink" href="#typical-use-cases" title="Permalink to this heading">#</a></h2>
<p>Isabelle/HOL is widely used for formal specification and rigorous proof of both mathematical theorems and system properties. It supports expressing precise logical models and verifying them interactively with automation (via the Sledgehammer tool), making it suitable for a variety of tasks such as formalizing algorithms, verifying software and hardware correctness, and reasoning about programming language semantics and protocols. Isabelle/HOL has been used in many different verification projects, such as through the large body of libraries and developments collected in the Archive of Formal Proofs (AFP)<sup><a href="#AFP_History">[27]</a></sup> and as evidenced by the examples in <span class="xref myst">Section 8.9</span>.</p>
</section>
<section id="benchmarks-and-competitions">
<h2><span class="section-number">8.9. </span>Benchmarks and Competitions<a class="headerlink" href="#benchmarks-and-competitions" title="Permalink to this heading">#</a></h2>
<p><strong>miniF2F</strong> is a cross-system benchmark of 488 problem statements drawn from both mathematical competitions (IME, AMC and the International Mathematical Olympiad) and high school and undergraduate level mathematics courses. The benchmark targets theorem provers such as Lean, Metamath, Isabelle, and HOL Light in order to enable cross-system comparison of theorem provers and proof automation tools. The goal is to serve as a benchmark for automated and neural theorem proving systems. A formal problem statement is fed into system and the prover must output a fully machine-verifiable proof.<sup><a href="#MiniF2F">[29]</a></sup>
<strong>miniF2F</strong> is a cross-system benchmark of 488 problem statements drawn from both mathematical competitions (IME, AMC and the International Mathematical Olympiad) and high school and undergraduate level mathematics courses. The benchmark targets theorem provers such as Lean, Metamath, Isabelle, and HOL Light in order to enable cross-system comparison of theorem provers and proof automation tools. The goal is to serve as a benchmark for automated and neural theorem proving systems. A formal problem statement is fed into system and the prover must output a fully machine-verifiable proof.<sup><a href="#MiniF2F">[29]</a></sup></p>
<p><strong>TPTP</strong> (Thousands of Problems for Theorem Provers) is a library of test problems for testing and evaluating ATPs. Problems are expressed in a simple text-based format for either first-order logic or higher-order logic. TPTP provides a common benchmark with a single, unambiguous reference set of problems so that different ATP systems can be both evaluated and compared with reproducible results.<sup><a href="#TPTP">[36]</a></sup>
<strong>TPTP</strong> (Thousands of Problems for Theorem Provers) is a library of test problems for testing and evaluating ATPs. Problems are expressed in a simple text-based format for either first-order logic or higher-order logic. TPTP provides a common benchmark with a single, unambiguous reference set of problems so that different ATP systems can be both evaluated and compared with reproducible results.<sup><a href="#TPTP">[36]</a></sup></p>
<p><strong>CASC</strong> (The CADE ATP System Competition) is an annual competition of fully automatic, classical logic, ATP systems. The purpose of CASC is to provide a public evaluation of relative capabilities of ATP systems as well as to stimulate research and development of ATP systems. At CASC, ATP system performance is evaluated in terms of the total number of problems solved with an acceptable solution output within a specified time limit, as well as the average time taken for problems solved. CASC is hosted at each CADE and IJCAR conference, both forums for automated deduction.<sup><a href="#CASC">[37]</a></sup>
<strong>CASC</strong> (The CADE ATP System Competition) is an annual competition of fully automatic, classical logic, ATP systems. The purpose of CASC is to provide a public evaluation of relative capabilities of ATP systems as well as to stimulate research and development of ATP systems. At CASC, ATP system performance is evaluated in terms of the total number of problems solved with an acceptable solution output within a specified time limit, as well as the average time taken for problems solved. CASC is hosted at each CADE and IJCAR conference, both forums for automated deduction.<sup><a href="#CASC">[37]</a></sup></p>
</section>
<section id="applications-in-industry-and-academia">
<h2><span class="section-number">8.10. </span>Applications in Industry and Academia<a class="headerlink" href="#applications-in-industry-and-academia" title="Permalink to this heading">#</a></h2>
<p>In general, Isabelle/HOL appears to have a wide variety of application throughout industry and academia due to the fact that it provides a mathematical assurance of correctness (rather than testing alone). The tool is particularly suited to safety critical systems, such as avionics, embedded systems, industrial process control, SoC design, etc where fault risk must be minimized and certification standards demand high trust.
In general, Isabelle/HOL appears to have a wide variety of application throughout industry and academia due to the fact that it provides a mathematical assurance of correctness (rather than testing alone). The tool is particularly suited to safety critical systems, such as avionics, embedded systems, industrial process control, SoC design, etc where fault risk must be minimized and certification standards demand high trust.</p>
<section id="physical-addressing-on-real-hardware">
<h3><span class="section-number">8.10.1. </span>Physical Addressing on Real Hardware<a class="headerlink" href="#physical-addressing-on-real-hardware" title="Permalink to this heading">#</a></h3>
<p>Achermann et al.<sup><a href="#Achermann_physicalAddressing">[19]</a></sup> discuss how to formally model and verify physical memory address translation and remapping hardware (such as MMUs) in SoCs (Systems-on-Chip) using Isabelle/HOL. Specifically, they developed a hardware model that encodes translation units and then prove that standard memory operations preserve system invariants.
Achermann et al.<sup><a href="#Achermann_physicalAddressing">[19]</a></sup> discuss how to formally model and verify physical memory address translation and remapping hardware (such as MMUs) in SoCs (Systems-on-Chip) using Isabelle/HOL. Specifically, they developed a hardware model that encodes translation units and then prove that standard memory operations preserve system invariants.</p>
</section>
<section id="focus-stream-processing-components">
<h3><span class="section-number">8.10.2. </span>FOCUS - Stream Processing Components<a class="headerlink" href="#focus-stream-processing-components" title="Permalink to this heading">#</a></h3>
<p>Spichkova<sup><a href="#Spichkova_FOCUS">[20]</a></sup> introduces FOCUS, a framework for formal specification and refinement-based verification of interactive systems. Based on stream-processing semantics that model communication histories over directed channels, FOCUS is supported by Isabelle/HOL using the Isar proof language. FOCUS is evaluated on three case studies:</p>
<ul class="simple">
<li><p>a steam boiler control system modelled as a distributed real-time system with proofs that water levels and pump actuations satisfy safety and timing constraints</p></li>
<li><p>the FlexRay automotive communication protocol, where FOCUS verifies correct static schedules, channel behavior, and broadcast properties for safety-critical embedded communication</p></li>
<li><p>an Automotive-Gateway system from the Verisoft project, formally specified and refined with guarantees that crash signals trigger correct emergency-service calls and satisfy required data-handling properties.</p></li>
</ul>
<!-- 
FOCUS uses Isabelle/HOL with the Isar language with three distinct case studies, namely process control (Steam Boiler System), data transmission (FlexRay communication protocol), memory and processing components (Automotive-Gateway System).

- The first case study is about a generic steam boiler system, which is represented as a distributed system with communicating components. In addition, the system must meet real time requirements such as ensuring water levels stay within bounds and when to appropriately actuate the water pumps. The system is formalized in Isabelle/HOL, translating architecture and component behavior into higher-order logic while proving the design satisfies timing and safety requirements.
- The first case study is about a generic steam boiler system, which is represented as a distributed system with communicating components. In addition, the system must meet real time requirements such as ensuring water levels stay within bounds and when to appropriately actuate the water pumps. The system is formalized in Isabelle/HOL, translating architecture and component behavior into higher-order logic while proving the design satisfies timing and safety requirements.

- The second case study is about FlexRay, which is a communication protocol for safety-critical real-time applications, specifically embedded systems in vehicles. FOCUS is used in this case to verify and prove correct static cycles, channel scheduling and properties, and node broadcast behavior.
- The second case study is about FlexRay, which is a communication protocol for safety-critical real-time applications, specifically embedded systems in vehicles. FOCUS is used in this case to verify and prove correct static cycles, channel scheduling and properties, and node broadcast behavior.

- The third case study is about the Automative-Gateway system for the Verisoft project. Basically, if the Gateway receives a vehicle crash signal, then it will initiate a call to the appropriate Emergency Service Center (ESC). The system is modelled in Isabelle/HOL, with the architecture, requirements, and refinement relations all formally specified and proven to ensure that the Gateway design meets its crash signal and data transmission requirements. -->
</section>
<section id="isabil-verifying-in-correctness-of-binaries">
<h3><span class="section-number">8.10.3. </span>IsaBIL - Verifying (In)Correctness of Binaries<a class="headerlink" href="#isabil-verifying-in-correctness-of-binaries" title="Permalink to this heading">#</a></h3>
<p>Griffin et al.<sup><a href="#Griffin_IsaBIL">[21]</a></sup> present IsaBIL, a binary analysis framework in Isabelle/HOL that is based on BAP (Binary Analysis Platform). IsaBIL formalizes BAP’s intermediate language (BIL) and integrates it with Hoare Logic (for proofs of correctness) and incorrectness logic (for proofs of incorrectness). While there is a primary focus is on the RISC-V architecture and C binaries, the authors assert that IsaBIL is a flexible framework that can verify binaries for different languages (C, C++, Rust), toolchains (LLVM, Ghidra), and architectures (x86, RISC-V). The authors prove correctness through some industry level examples such as Lockheed Martin’s JSF (Joint Strike Fighter) coding standards and the MITRE ATT&amp;CK database.
Griffin et al.<sup><a href="#Griffin_IsaBIL">[21]</a></sup> present IsaBIL, a binary analysis framework in Isabelle/HOL that is based on BAP (Binary Analysis Platform). IsaBIL formalizes BAP’s intermediate language (BIL) and integrates it with Hoare Logic (for proofs of correctness) and incorrectness logic (for proofs of incorrectness). While there is a primary focus is on the RISC-V architecture and C binaries, the authors assert that IsaBIL is a flexible framework that can verify binaries for different languages (C, C++, Rust), toolchains (LLVM, Ghidra), and architectures (x86, RISC-V). The authors prove correctness through some industry level examples such as Lockheed Martin’s JSF (Joint Strike Fighter) coding standards and the MITRE ATT&amp;CK database.</p>
</section>
<section id="verlso-isolation-guarantees-of-database-transactions">
<h3><span class="section-number">8.10.4. </span>Verlso - Isolation Guarantees of Database Transactions<a class="headerlink" href="#verlso-isolation-guarantees-of-database-transactions" title="Permalink to this heading">#</a></h3>
<p>Ghasemirad et al.<sup><a href="#Ghasemirad_VerIso">[7]</a></sup> present VerIso, a rigorous Isabelle/HOL-based framework for verifying transaction isolation within production level databases. The authors showcase VerIso by modelling the strict two-phase locking (S2PL) protocol and prove that it provides strict serializability (transactions behave as if executed sequentially and that sequential order must match the actual time order of their invocation/commit). In addition, VerIso’s parameterized architecture supports multiple isolation levels and uncovers design-level bugs in protocols such as the TAPIR protocol and its violation of atomic visibility.
Ghasemirad et al.<sup><a href="#Ghasemirad_VerIso">[7]</a></sup> present VerIso, a rigorous Isabelle/HOL-based framework for verifying transaction isolation within production level databases. The authors showcase VerIso by modelling the strict two-phase locking (S2PL) protocol and prove that it provides strict serializability (transactions behave as if executed sequentially and that sequential order must match the actual time order of their invocation/commit). In addition, VerIso’s parameterized architecture supports multiple isolation levels and uncovers design-level bugs in protocols such as the TAPIR protocol and its violation of atomic visibility.</p>
</section>
<section id="ieee-754-floating-point-implementation-for-mdps">
<h3><span class="section-number">8.10.5. </span>IEEE 754 Floating Point Implementation for MDPs<a class="headerlink" href="#ieee-754-floating-point-implementation-for-mdps" title="Permalink to this heading">#</a></h3>
<p>Kohlen et al.<sup><a href="#Kohlen_float">[22]</a></sup> present a fully verified implementation of the Interval Iteration (II) Algorithm for Markov Decision Processes (MDPs). They model the II algorithm in Isabelle/HOL, use the Isabelle Refinement Framework (IRF) to carry out step-wise refinement down to LLVM bytecode, and extend Isabelle/HOL’s reasoning to support IEEE 754 floating-point arithmetic with directed rounding. Their result is a correct-by-construction floating-point implementation, competitive with industry tools and highly relevant for domains where verified numerical correctness matters, such as embedded systems, SoCs and safety-critical software.
Kohlen et al.<sup><a href="#Kohlen_float">[22]</a></sup> present a fully verified implementation of the Interval Iteration (II) Algorithm for Markov Decision Processes (MDPs). They model the II algorithm in Isabelle/HOL, use the Isabelle Refinement Framework (IRF) to carry out step-wise refinement down to LLVM bytecode, and extend Isabelle/HOL’s reasoning to support IEEE 754 floating-point arithmetic with directed rounding. Their result is a correct-by-construction floating-point implementation, competitive with industry tools and highly relevant for domains where verified numerical correctness matters, such as embedded systems, SoCs and safety-critical software.</p>
<!-- ### 10.8.6 IsaMini: Isabelle Proof Language for Machine Learning

Xu et al. present MiniLang/IsaMini, a streamlined proof language for Isabelle/HOL designed to improve Large Language Model (LLM) integration in formal verification. The authors convert existing Isar proofs, such as those within Isabelle's Archive of Formal Proofs (AFP), into MiniLang and fine-tune LLMs on this new proof representation. They then use the LLM's macro level proof planning alongside Isabelle's automation (such as Sledgehammer, etc) for micro level proof steps to significantly boost proof success rate. Their work is noteworthy because it brings together formal methods and AI-assisted tooling, reducing manual proof effort and enabling more scalable verification.<sup><a href="#Xu_IsaMini">[7]</a></sup> -->
<p>Xu et al. present MiniLang/IsaMini, a streamlined proof language for Isabelle/HOL designed to improve Large Language Model (LLM) integration in formal verification. The authors convert existing Isar proofs, such as those within Isabelle’s Archive of Formal Proofs (AFP), into MiniLang and fine-tune LLMs on this new proof representation. They then use the LLM’s macro level proof planning alongside Isabelle’s automation (such as Sledgehammer, etc) for micro level proof steps to significantly boost proof success rate. Their work is noteworthy because it brings together formal methods and AI-assisted tooling, reducing manual proof effort and enabling more scalable verification.<sup><a href="#Xu_IsaMini">[7]</a></sup> –&gt;</p>
</section>
<section id="autoformalization-with-large-language-models">
<h3><span class="section-number">8.10.6. </span>Autoformalization with Large Language Models<a class="headerlink" href="#autoformalization-with-large-language-models" title="Permalink to this heading">#</a></h3>
<p>Wu et al.<sup><a href="#Wu_LLM_Autoformat">[24]</a></sup> show that large language models are particularly effective at performing autoformalization, which is the process of automatically translating natural language mathematics into formal specifications and proofs. Specifically, they note that 25.3% of mathematical competition problems were translated <em>perfectly</em> to formal Isabelle/HOL statements. In addition, by using these autoformalized statements to fine-tune an existing neural theorem prover, they managed to improve achieve a 35.2% proof rate on Mini2F2, compared to a baseline proof rate of 29.6%.</p>
</section>
</section>
<section id="case-study-autoformalization-with-llms">
<h2><span class="section-number">8.11. </span>Case Study - Autoformalization with LLMs<a class="headerlink" href="#case-study-autoformalization-with-llms" title="Permalink to this heading">#</a></h2>
</section>
<section id="id5">
<h2><span class="section-number">8.12. </span>Case Study - Autoformalization with LLMs<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h2>
<p>WIP</p>
<p>use this one:</p>
<p>https://openreview.net/forum?id=IUikebJ1Bf0</p>
</section>
<section id="history">
<h2><span class="section-number">8.13. </span>History<a class="headerlink" href="#history" title="Permalink to this heading">#</a></h2>
<section id="origins-of-higher-order-logic">
<h3><span class="section-number">8.13.1. </span>Origins of Higher-Order Logic<a class="headerlink" href="#origins-of-higher-order-logic" title="Permalink to this heading">#</a></h3>
<p>Alonzo Church’s work in the 1930s (via <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus)<sup><a href="#SEP_D.1_LambdaCalc">[39]</a></sup> and 1940s (via type theory)<sup><a href="#SEP_D.2_TypeTheory">[40]</a></sup> and Leon Henkin’s work in the 1950s (on general model/Henkin semantics)<sup><a href="#SEP_HOL">[7]</a></sup> lay the foundation for higher-order logic. From their contributions arose an extension of First-Order Logic (FOL) that allows quantification over predicates and functions, enabling reasoning about functions as first class entities.
Alonzo Church’s work in the 1930s (via <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus)<sup><a href="#SEP_D.1_LambdaCalc">[39]</a></sup> and 1940s (via type theory)<sup><a href="#SEP_D.2_TypeTheory">[40]</a></sup> and Leon Henkin’s work in the 1950s (on general model/Henkin semantics)<sup><a href="#SEP_HOL">[7]</a></sup> lay the foundation for higher-order logic. From their contributions arose an extension of First-Order Logic (FOL) that allows quantification over predicates and functions, enabling reasoning about functions as first class entities.</p>
<p>In the 1970s, Robert Milner develops LCF (Logic for Computable Functions)<sup><a href="#LCF_HOL_history">[38]</a></sup> at Stanford and later Edinburgh, introducing the idea of an interactive theorem prover. LCF pioneers the use of a tactic-based proof automation and the ML meta language, which is designed to let users safely define proof strategies. ML later evolves into OCaml and Standard ML.
In the 1970s, Robert Milner develops LCF (Logic for Computable Functions)<sup><a href="#LCF_HOL_history">[38]</a></sup> at Stanford and later Edinburgh, introducing the idea of an interactive theorem prover. LCF pioneers the use of a tactic-based proof automation and the ML meta language, which is designed to let users safely define proof strategies. ML later evolves into OCaml and Standard ML.</p>
<p>In the early 1980s, Michael J. C. Gordon builds upon LCF in order to create the HOL system<sup><a href="#LCF_HOL_history">[38]</a></sup>, which explicitly uses higher-order logic as its core formalism. This HOL system would become the foundation for hardware verification, paving the way and influencing later provers like HOL4 and Isabelle/HOL.
In the early 1980s, Michael J. C. Gordon builds upon LCF in order to create the HOL system<sup><a href="#LCF_HOL_history">[38]</a></sup>, which explicitly uses higher-order logic as its core formalism. This HOL system would become the foundation for hardware verification, paving the way and influencing later provers like HOL4 and Isabelle/HOL.</p>
</section>
<section id="development-of-isabelle-hol">
<h3><span class="section-number">8.13.2. </span>Development of Isabelle/HOL<a class="headerlink" href="#development-of-isabelle-hol" title="Permalink to this heading">#</a></h3>
<p>Developed in the late 1980’s by Lawrence C. Paulson at Cambridge, Isabelle was created as a generic theorem proving framework capable of supporting multiple logical formalisms under a single meta-logic.<sup><a href="#LCF_Isabelle_History">[26]</a></sup>
Developed in the late 1980’s by Lawrence C. Paulson at Cambridge, Isabelle was created as a generic theorem proving framework capable of supporting multiple logical formalisms under a single meta-logic.<sup><a href="#LCF_Isabelle_History">[26]</a></sup></p>
<p>The HOL instantiation of Isabelle (Isabelle/HOL) became the most widely adopted version due to its strong expressiveness and balance between automation and manual control.<sup><a href="#LCF_Isabelle_History">[26]</a></sup>
The HOL instantiation of Isabelle (Isabelle/HOL) became the most widely adopted version due to its strong expressiveness and balance between automation and manual control.<sup><a href="#LCF_Isabelle_History">[26]</a></sup></p>
<p>Markus Wenzel proposed and developed the Isar Proof Language<sup><a href="#Isar_History">[17]</a></sup> for Isabelle between 1998 and 2001. Isar allows for more structured and human readable proofs, improving clarity over traditional tactic-based approaches like in LCF.
Markus Wenzel proposed and developed the Isar Proof Language<sup><a href="#Isar_History">[17]</a></sup> for Isabelle between 1998 and 2001. Isar allows for more structured and human readable proofs, improving clarity over traditional tactic-based approaches like in LCF.</p>
<p>The creation of the Archive of Formal Proofs (AFP) in 2004 established a large, community-driven library of formalized mathematics and computer science. The establishment of the AFP solidified Isabelle/HOL’s role in both academia and industry.<sup><a href="#AFP_History">[27]</a></sup>
The creation of the Archive of Formal Proofs (AFP) in 2004 established a large, community-driven library of formalized mathematics and computer science. The establishment of the AFP solidified Isabelle/HOL’s role in both academia and industry.<sup><a href="#AFP_History">[27]</a></sup></p>
<p>The integration of tools such as Sledgehammer and external SMT/ATP solvers in 2007 further extend Isabelle/HOL’s proof power. The bridging of interactive reasoning and automation allows user to tackle complex goals with minimal manual effort.<sup><a href="#Isabelle_Sledgehammer">[35]</a></sup>
The integration of tools such as Sledgehammer and external SMT/ATP solvers in 2007 further extend Isabelle/HOL’s proof power. The bridging of interactive reasoning and automation allows user to tackle complex goals with minimal manual effort.<sup><a href="#Isabelle_Sledgehammer">[35]</a></sup></p>
<!-- ## Formal Methods and AI

Not sure if this section is necessary since there are already sections that deal with NTP, LLMs in formal verification, autoformalization, etc. -->
</section>
</section>
<section id="current-events-within-isabelle-hol">
<h2><span class="section-number">8.14. </span>Current Events within Isabelle/HOL<a class="headerlink" href="#current-events-within-isabelle-hol" title="Permalink to this heading">#</a></h2>
<section id="current-development">
<h3><span class="section-number">8.14.1. </span>Current Development<a class="headerlink" href="#current-development" title="Permalink to this heading">#</a></h3>
<p>Active research is increasingly integrating generative and large language models (LLMs) with interactive theorem proving to reduce manual proof construction. This emerging paradigm, termed <em>Neural Theorem Proving (NTP)</em>, augments classic automatic theorem proving (ATP) by integrating generative AI with symbolic proof assistants like Isabelle/HOL to enhance automation, guide proof search, and address complex formal reasoning tasks. Recent work by Xu et al. introduces MiniLang/IsaMini<sup><a href="#Xu_IsaMini">[25]</a></sup>, an intermediate proof language designed to improve LLM performance in Isabelle/HOL and significantly boost success rates on standard proof benchmarks compared to generating Isar scripts directly. NTP and hybrid AI frameworks are also being developed to generate and structure complete formal proofs, fine-tune models for syntactically correct proof output, and integrate verification backends to reduce errors and improve correctness in formal verification tasks. These efforts align with broader trends in formal methods research that explore how LLM reasoning can be combined with rigorous symbolic verification to enhance automation, benchmark performance, and increase formal verification scalability.</p>
</section>
<section id="research-challenges">
<h3><span class="section-number">8.14.2. </span>Research Challenges<a class="headerlink" href="#research-challenges" title="Permalink to this heading">#</a></h3>
<p>Despite ongoing advances, substantial research challenges remain in Isabelle/HOL’s ecosystem, particularly at the intersection of formal verification and generative AI. Interactive theorem proving in Isabelle/HOL still depends heavily on human guidance through structured Isar proofs, making large-scale developments both labor-intensive and error-prone. The integration of LLM-based techniques introduces additional difficulties, such as translating model output into Isabelle’s strict proof language, mitigating hallucinations and syntactic errors, and obtaining sufficiently large, high-quality datasets of formal proofs for training. While intermediate languages such as MiniLang/IsaMini<sup><a href="#Xu_IsaMini">[25]</a></sup> can significantly improve LLM performance, they also highlight the sensitivity of proof success to representation choices and data quality. Moreover, bridging the gap between informal specifications and fully formalized Isabelle theories, commonly termed <em>autoformalization</em><sup><a href="#Wu_LLM_Autoformat">[24]</a></sup>, remains a major obstacle, as current LLMs struggle to reliably produce complete, semantically correct formalizations without human intervention.</p>
</section>
<section id="conferences-and-workshops">
<h3><span class="section-number">8.14.3. </span>Conferences and Workshops<a class="headerlink" href="#conferences-and-workshops" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><strong><a class="reference external" href="https://itp-conference.github.io/">International Conference on Interactive Theorem Proving (ITP)</a></strong> - dedicated to interactive theorem proving and related topics, ranging from theoretical foundations to implementation aspects and applications in program verification, security, and formalization of mathematics.</p></li>
<li><p><strong><a class="reference external" href="https://sketis.net/isabelle/isabelle-workshop-2026">Isabelle Workshop</a></strong> - a workshop focused on Isabelle where users and developers can present tool developments, formalization projects, and ongoing research papers.</p></li>
<li><p><strong><a class="reference external" href="https://ijcar.org//conferences">International Joint Conference on Automated Reasoning (IJCAR)</a></strong> - international conference covering automated and interactive reasoning which merges several leading conferences and events, such as the Conference on Automated Deduction (CADE), TABLEAUX, and FroCoS, into a single forum covering foundations, tools, and applications in automated reasoning.</p></li>
<li><p><strong><a class="reference external" href="https://www.isa-afp.org/">Archive of Formal Proofs (AFP)</a></strong> - while not an explicit conference, the AFP functions like a curated repository and journal for Isabelle/HOL proofs, hosting a large collection of mechanically checked proof libraries and scientific developments that are often associated with conference or journal publications.</p></li>
</ul>
</section>
</section>
<section id="references">
<h2><span class="section-number">8.15. </span>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<style>
.citation-entry:target {
  background-color: rgba(201, 184, 91, 0.35);
  padding: 4px 8px;
  border-left: 3px solid #e0b400;
  transition: background-color 0.25s ease;
  scroll-margin-top: 3rem;
}
</style>
<section id="ebooks-and-textbooks">
<h3><span class="section-number">8.15.1. </span>eBooks and Textbooks<a class="headerlink" href="#ebooks-and-textbooks" title="Permalink to this heading">#</a></h3>
</section>
<section id="id6">
<h3><span class="section-number">8.15.2. </span>eBooks and Textbooks<a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h3>
<ul>
  <li id="ConcreteSemantics" class="citation-entry">
    [1]: Nipkow and Klein (2014)
    <a href="http://www.concrete-semantics.org/index.html">Concrete Semantics: With Isabelle/HOL</a>, Springer Publishing Company, Incorporated.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Isabelle_Logics" class="citation-entry">
    [2]: Nipkow, Paulson, and Wenzel (2009)
    <a href="https://isabelle.in.tum.de/website-Isabelle2009-1/dist/Isabelle/doc/logics-HOL.pdf">Isabelle’s Logics: HOL</a>, Isabelle2009 Documentation.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Isabelle/HOL_ProofAssistant" class="citation-entry">
    [3]: Nipkow, Paulson, and Wenzel (2025)
    <a href="https://isabelle.in.tum.de/doc/tutorial.pdf">Isabelle/HOL: A Proof Assistant for Higher-Order Logic</a>, Springer-Verlag.
  <li id="Isabelle_Logics" class="citation-entry">
    [2]: Nipkow, Paulson, and Wenzel (2009)
    <a href="https://isabelle.in.tum.de/website-Isabelle2009-1/dist/Isabelle/doc/logics-HOL.pdf">Isabelle’s Logics: HOL</a>, Isabelle2009 Documentation.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Isabelle/HOL_ProofAssistant" class="citation-entry">
    [3]: Nipkow, Paulson, and Wenzel (2025)
    <a href="https://isabelle.in.tum.de/doc/tutorial.pdf">Isabelle/HOL: A Proof Assistant for Higher-Order Logic</a>, Springer-Verlag.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="andrews2002" class="citation-entry">
    [4]: Peter B. Andrews (2002)
    [4]: Peter B. Andrews (2002)
    <a href="https://dl.acm.org/doi/10.5555/581793#">Introduction to Mathematical Logic and Type Theory: To Truth through Proof (2nd. ed.)</a>, Kluwer Academic Publishers, USA.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Paulson_LCF" class="citation-entry">
    [5]: Laurence C. Paulson (1987)
    <a href="https://assets.cambridge.org/97805213/46320/sample/9780521346320ws.pdf">Logic and Computation: Interactive Proof with Cambridge LCF</a>, Cambridge University Press, USA.
  <li id="Paulson_LCF" class="citation-entry">
    [5]: Laurence C. Paulson (1987)
    <a href="https://assets.cambridge.org/97805213/46320/sample/9780521346320ws.pdf">Logic and Computation: Interactive Proof with Cambridge LCF</a>, Cambridge University Press, USA.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Teege_IntroIsabelle" class="citation-entry">
    [6]: Gunnar Teege (2025)
    <a href="https://github.com/gteege/gentle-isabelle/blob/main/man-isabelle.pdf">A Gentle Introduction to Isabelle and Isabelle/HOL</a>, Universität der Bundeswehr München.
  <li id="Teege_IntroIsabelle" class="citation-entry">
    [6]: Gunnar Teege (2025)
    <a href="https://github.com/gteege/gentle-isabelle/blob/main/man-isabelle.pdf">A Gentle Introduction to Isabelle and Isabelle/HOL</a>, Universität der Bundeswehr München.
  </li>
</ul>
</section>
<section id="online-articles">
<h3><span class="section-number">8.15.3. </span>Online Articles<a class="headerlink" href="#online-articles" title="Permalink to this heading">#</a></h3>
<ul>
</ul>
</section>
<section id="id7">
<h3><span class="section-number">8.15.4. </span>Online Articles<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h3>
<ul>
  <li id="SEP_HOL" class="citation-entry">
    [7]: Jouko Väänänen (2024)
    <a href="https://plato.stanford.edu/entries/logic-higher-order/">Second-order and Higher-order Logic</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University
  <li id="SEP_HOL" class="citation-entry">
    [7]: Jouko Väänänen (2024)
    <a href="https://plato.stanford.edu/entries/logic-higher-order/">Second-order and Higher-order Logic</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="SEP_ChurchTypeTheory" class="citation-entry">
    [8]: Benzmüller and Andrews (2025)
    <a href="https://plato.stanford.edu/entries/type-theory-church/">Church’s Type Theory</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  <li id="SEP_ChurchTypeTheory" class="citation-entry">
    [8]: Benzmüller and Andrews (2025)
    <a href="https://plato.stanford.edu/entries/type-theory-church/">Church’s Type Theory</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="SEP_TypeTheory" class="citation-entry">
    [9]: Thierry Coquand (2022)
    <a href="https://plato.stanford.edu/entries/type-theory/">Type Theory</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University
  <li id="SEP_TypeTheory" class="citation-entry">
    [9]: Thierry Coquand (2022)
    <a href="https://plato.stanford.edu/entries/type-theory/">Type Theory</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Kurz_LambdaSemantics" class="citation-entry">
    [10]: Alexander Kurz (2023)
    <a href="https://hackmd.io/@alexhkurz/H1e4Nv8Bv">Semantics of the Lambda Calculus</a>, CPSC 354 Programming Languages, Chapman University.
  <li id="Kurz_LambdaSemantics" class="citation-entry">
    [10]: Alexander Kurz (2023)
    <a href="https://hackmd.io/@alexhkurz/H1e4Nv8Bv">Semantics of the Lambda Calculus</a>, CPSC 354 Programming Languages, Chapman University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Kurz_LambdaSyntax" class="citation-entry">
    [11]: Alexander Kurz (2023)
    <a href="https://hackmd.io/@alexhkurz/S1D0yP8Bw">Syntax of Lambda Calculus</a>, CPSC 354 Programming Languages, Chapman University.
  <li id="Kurz_LambdaSyntax" class="citation-entry">
    [11]: Alexander Kurz (2023)
    <a href="https://hackmd.io/@alexhkurz/S1D0yP8Bw">Syntax of Lambda Calculus</a>, CPSC 354 Programming Languages, Chapman University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Stanford_LambdaCalc_TypeTheory" class="citation-entry">
    [12]: Deutsch and Marshall (2025)
    <a href="https://plato.stanford.edu/entries/church/supplementD.html">Supplement D: The λ-Calculus and Type Theory</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="SEP_D.1_LambdaCalc" class="citation-entry">
    [39]: Deutsch and Marshall (2025)
    <a href="https://plato.stanford.edu/entries/church/supplementD.html#D1ChurLambCalc">D.1 Church’s Lambda Calculus</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  <li id="SEP_D.1_LambdaCalc" class="citation-entry">
    [39]: Deutsch and Marshall (2025)
    <a href="https://plato.stanford.edu/entries/church/supplementD.html#D1ChurLambCalc">D.1 Church’s Lambda Calculus</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="SEP_D.2_TypeTheory" class="citation-entry">
    [40]: Deutsch and Marshall (2025)
    <a href="https://plato.stanford.edu/entries/church/supplementD.html#D2ChurSimpTheoType">D.2 Church’s Simple Theory of Types</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  <li id="SEP_D.2_TypeTheory" class="citation-entry">
    [40]: Deutsch and Marshall (2025)
    <a href="https://plato.stanford.edu/entries/church/supplementD.html#D2ChurSimpTheoType">D.2 Church’s Simple Theory of Types</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="SEP_LambdaCalc" class="citation-entry">
    [13]: Alama and Korbmacher (2023)
    <a href="https://plato.stanford.edu/archives/win2024/entries/lambda-calculus/">The Lambda Calculus</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  <li id="SEP_LambdaCalc" class="citation-entry">
    [13]: Alama and Korbmacher (2023)
    <a href="https://plato.stanford.edu/archives/win2024/entries/lambda-calculus/">The Lambda Calculus</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="SEP_CategTheory" class="citation-entry">
    [14]: Jean-Pierre Marquis (2023)
    <a href="https://plato.stanford.edu/entries/category-theory/">Category Theory</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University
  <li id="SEP_CategTheory" class="citation-entry">
    [14]: Jean-Pierre Marquis (2023)
    <a href="https://plato.stanford.edu/entries/category-theory/">Category Theory</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="SEP_AutomatedReasoning_HOL" class="citation-entry">
    [15]: Frederic Portoraro (2025)
    <a href="https://plato.stanford.edu/entries/reasoning-automated/#HigOrdLog">Automated Reasoning: Section 3.1 on Higher-Order Logic</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  <li id="SEP_AutomatedReasoning_HOL" class="citation-entry">
    [15]: Frederic Portoraro (2025)
    <a href="https://plato.stanford.edu/entries/reasoning-automated/#HigOrdLog">Automated Reasoning: Section 3.1 on Higher-Order Logic</a>, The Stanford Encyclopedia of Philosophy, Metaphysics Research Lab, Stanford University.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Satallax" class="citation-entry">
    [16]: Chad E. Brown (2012)
    [16]: Chad E. Brown (2012)
    <a href="https://ps.uni-saarland.de/Publications/documents/Brown2012b.pdf">Satallax: An Automatic Higher-Order Prover</a>, Saarland University, Saarbr¨ucken, Germany.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Isar_History" class="citation-entry">
    [17]: Makarius (Markus) Wenzel (1999)
    <a href="https://web.cs.wpi.edu/~dd/resources_isabelle/Isar-TPHOLs99.wenzel.pdf">Isar — a Generic Interpretative Approach to Readable Formal Proof Documents</a>, Theorem Proving in Higher Order Logics (TPHOLs 1999), volume 1690 of Lecture Notes in Computer Science. Springer-Verlag.
  </li>
</ul>
</section>
<section id="research-papers">
<h3><span class="section-number">8.15.5. </span>Research Papers<a class="headerlink" href="#research-papers" title="Permalink to this heading">#</a></h3>
<ul>
  <li id="Church_TypeTheory" class="citation-entry">
    [18]: Alonzo Church (1940)
    <a href="https://www.jstor.org/stable/2266170">A Formulation of the Simple Theory of Types</a>, The Journal of Symbolic Logic 5(2): 56–68.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Achermann_physicalAddressing" class="citation-entry">
    [19]: Achermann, Humbel, Cock, and Roscoe (2018)
    <a href="https://people.inf.ethz.ch/troscoe/pubs/achermann_itp_2018.pdf">Physical Addressing on Real Hardware in Isabelle/HOL</a>, Department of Computer Science, ETH Zurich.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Spichkova_FOCUS" class="citation-entry">
    [20]: Maria Spichkova (2014)
    <a href="https://arxiv.org/abs/1405.1512">Stream processing components: Isabelle/HOL formalisation and case studies</a>, arXiv preprint arXiv:1405.1512.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Griffin_IsaBIL" class="citation-entry">
    [21]: Griffin, Dongol, and Raad (2025)
    <a href="https://arxiv.org/abs/2504.16775v1">IsaBIL: A Framework for Verifying (In)correctness of Binaries in Isabelle/HOL (Extended Version)</a>, arXiv preprint arXiv:2504.16775.
  <li id="Isar_History" class="citation-entry">
    [17]: Makarius (Markus) Wenzel (1999)
    <a href="https://web.cs.wpi.edu/~dd/resources_isabelle/Isar-TPHOLs99.wenzel.pdf">Isar — a Generic Interpretative Approach to Readable Formal Proof Documents</a>, Theorem Proving in Higher Order Logics (TPHOLs 1999), volume 1690 of Lecture Notes in Computer Science. Springer-Verlag.
  </li>
</ul>
</section>
<section id="id8">
<h3><span class="section-number">8.15.6. </span>Research Papers<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h3>
<ul>
  <li id="Church_TypeTheory" class="citation-entry">
    [18]: Alonzo Church (1940)
    <a href="https://www.jstor.org/stable/2266170">A Formulation of the Simple Theory of Types</a>, The Journal of Symbolic Logic 5(2): 56–68.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Achermann_physicalAddressing" class="citation-entry">
    [19]: Achermann, Humbel, Cock, and Roscoe (2018)
    <a href="https://people.inf.ethz.ch/troscoe/pubs/achermann_itp_2018.pdf">Physical Addressing on Real Hardware in Isabelle/HOL</a>, Department of Computer Science, ETH Zurich.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Spichkova_FOCUS" class="citation-entry">
    [20]: Maria Spichkova (2014)
    <a href="https://arxiv.org/abs/1405.1512">Stream processing components: Isabelle/HOL formalisation and case studies</a>, arXiv preprint arXiv:1405.1512.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Griffin_IsaBIL" class="citation-entry">
    [21]: Griffin, Dongol, and Raad (2025)
    <a href="https://arxiv.org/abs/2504.16775v1">IsaBIL: A Framework for Verifying (In)correctness of Binaries in Isabelle/HOL (Extended Version)</a>, arXiv preprint arXiv:2504.16775.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Ghasemirad_VerIso" class="citation-entry">
    [22]: Ghasemirad et al. (2025)
    <a href="https://arxiv.org/abs/2503.06284">VerIso: Verifiable isolation guarantees for database transactions</a>, arXiv preprint arXiv:2503.06284.
  <li id="Ghasemirad_VerIso" class="citation-entry">
    [22]: Ghasemirad et al. (2025)
    <a href="https://arxiv.org/abs/2503.06284">VerIso: Verifiable isolation guarantees for database transactions</a>, arXiv preprint arXiv:2503.06284.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Kohlen_float" class="citation-entry">
    [23]: Kohlen et al. (2025)
    <a href="https://arxiv.org/abs/2501.10127v3">A formally verified IEEE 754 floating-point implementation of interval iteration for MDPs</a>, International Conference on Computer Aided Verification, Cham: Springer Nature Switzerland.
  <li id="Kohlen_float" class="citation-entry">
    [23]: Kohlen et al. (2025)
    <a href="https://arxiv.org/abs/2501.10127v3">A formally verified IEEE 754 floating-point implementation of interval iteration for MDPs</a>, International Conference on Computer Aided Verification, Cham: Springer Nature Switzerland.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Wu_LLM_Autoformat" class="citation-entry">
    [24]: Wu et al. (2022)
    <a href="https://openreview.net/forum?id=IUikebJ1Bf0">Autoformalization with Large Language Models</a>, NeurIPS 2022 Conference.
  <li id="Wu_LLM_Autoformat" class="citation-entry">
    [24]: Wu et al. (2022)
    <a href="https://openreview.net/forum?id=IUikebJ1Bf0">Autoformalization with Large Language Models</a>, NeurIPS 2022 Conference.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Xu_IsaMini" class="citation-entry">
    [25]: Xu et al. (2025)
    <a href="https://arxiv.org/abs/2507.18885">IsaMini: Redesigned Isabelle Proof Language for Machine Learning</a>, arXiv preprint arXiv:2507.18885.
  <li id="Xu_IsaMini" class="citation-entry">
    [25]: Xu et al. (2025)
    <a href="https://arxiv.org/abs/2507.18885">IsaMini: Redesigned Isabelle Proof Language for Machine Learning</a>, arXiv preprint arXiv:2507.18885.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="LCF_Isabelle_History" class="citation-entry">
    [26]: Paulson, Nipkow, and Wenzel (2019)  
    <a href="https://arxiv.org/abs/1907.02836">From LCF to Isabelle/HOL</a>, Formal Aspects of Computing 31.6 (2019): 675-698.
  <li id="LCF_Isabelle_History" class="citation-entry">
    [26]: Paulson, Nipkow, and Wenzel (2019)  
    <a href="https://arxiv.org/abs/1907.02836">From LCF to Isabelle/HOL</a>, Formal Aspects of Computing 31.6 (2019): 675-698.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="AFP_History" class="citation-entry">
    [27]: Makarius (Markus) Wenzel (2019)
    <a href="https://arxiv.org/abs/1905.07244">Isabelle technology for the Archive of Formal Proofs with application to MMT</a>, arXiv preprint arXiv:1905.07244.
  <li id="AFP_History" class="citation-entry">
    [27]: Makarius (Markus) Wenzel (2019)
    <a href="https://arxiv.org/abs/1905.07244">Isabelle technology for the Archive of Formal Proofs with application to MMT</a>, arXiv preprint arXiv:1905.07244.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="LeoIII" class="citation-entry">
    [28]: Steen and Benzmüller (2018)
    <a href="https://arxiv.org/abs/1802.02732">The Higher-Order Prover Leo-III (Extended Version)</a>, IJCAR 2018, Oxford, UK.
  <li id="LeoIII" class="citation-entry">
    [28]: Steen and Benzmüller (2018)
    <a href="https://arxiv.org/abs/1802.02732">The Higher-Order Prover Leo-III (Extended Version)</a>, IJCAR 2018, Oxford, UK.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="MiniF2F" class="citation-entry">
    [29]: Zheng, Han, and Polu (2022)
    <a href="https://arxiv.org/abs/2109.00110">MiniF2F: A Cross-System Benchmark for Formal Olympiad-Level Mathematics</a>, ICLR 2022.
  </li>
</ul>
</section>
<section id="videos">
<h3><span class="section-number">8.15.7. </span>Videos<a class="headerlink" href="#videos" title="Permalink to this heading">#</a></h3>
<ul>
  <li id="MiniF2F" class="citation-entry">
    [29]: Zheng, Han, and Polu (2022)
    <a href="https://arxiv.org/abs/2109.00110">MiniF2F: A Cross-System Benchmark for Formal Olympiad-Level Mathematics</a>, ICLR 2022.
  </li>
</ul>
</section>
<section id="id9">
<h3><span class="section-number">8.15.8. </span>Videos<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h3>
<ul>
  <li id="LigerLearn_LambdaPrimer" class="citation-entry">
    [30]: LigerLearn (2023)
    [30]: LigerLearn (2023)
    <a href="https://www.youtube.com/watch?v=9MtE5ONrQyk">Lambda (λ) Calculus Primer</a>, YouTube.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="LigerLearn_LambdaEval" class="citation-entry">
    [31]: LigerLearn (2023)
    [31]: LigerLearn (2023)
    <a href="https://www.youtube.com/watch?v=VS_GK-9xUO4">Lambda (λ) calculus evaluation rules (δ, β, α, η conversion/reduction)</a>, YouTube.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="TypeTheory_Youtube" class="citation-entry">
    [32]: Mark Jago / Attic Philosophy (2025)
    [32]: Mark Jago / Attic Philosophy (2025)
    <a href="https://www.youtube.com/watch?v=TrYosPPCQAY">Type Theory in Computer Science, Linguistics, Logic</a>, YouTube.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Lugg_CategoryTheory" class="citation-entry">
    [33]: Oliver Lugg (2022)
    [33]: Oliver Lugg (2022)
    <a href="https://www.youtube.com/watch?v=yAi3XWCBkDo">A Sensible Introduction to Category Theory</a>, YouTube.
  </li>
</ul>
</section>
<section id="miscellaneous">
<h3><span class="section-number">8.15.9. </span>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this heading">#</a></h3>
<ul>
  <li id="MossSyllogism" class="citation-entry">
    [34]: Larry Moss (2015)
    <a href="https://logic.berkeley.edu/colloquium/MossSlides.pdf">Natural Logic</a>, UC Berkeley Logic Seminar.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="Isabelle_Sledgehammer" class="citation-entry">
    [35]: Blanchette, Desharnais, Paulson, and Bartl (2025)
    [35]: Blanchette, Desharnais, Paulson, and Bartl (2025)
    <a href="https://isabelle.in.tum.de/doc/sledgehammer.pdf">Hammering Away: A User’s Guide to Sledgehammer for Isabelle/HOL</a>, Isabelle 2025 Documentation
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="TPTP" class="citation-entry">
    [36]: Geoff Sutcliffe (2017)
    <a href="https://tptp.org/TPTP/">The TPTP Problem Library and Associated Infrastructure: From CNF to TH0</a>, Journal of Automated Reasoning 59(4): 483–502.
  <li id="TPTP" class="citation-entry">
    [36]: Geoff Sutcliffe (2017)
    <a href="https://tptp.org/TPTP/">The TPTP Problem Library and Associated Infrastructure: From CNF to TH0</a>, Journal of Automated Reasoning 59(4): 483–502.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="CASC" class="citation-entry">
    [37]: Geoff Sutcliffe (2016)
    <a href="https://tptp.org/CASC/">The CADE ATP System Competition – CASC</a>, AI Magazine 37(2): 99–101.
  <li id="CASC" class="citation-entry">
    [37]: Geoff Sutcliffe (2016)
    <a href="https://tptp.org/CASC/">The CADE ATP System Competition – CASC</a>, AI Magazine 37(2): 99–101.
  </li>
<p><span style="display:block; height:0.1em;"></span></p>
  <li id="LCF_HOL_history" class="citation-entry">
    [38]: Mike Gordon (1996)
    <a href="https://www.cl.cam.ac.uk/archive/mjcg/papers/HolHistory.pdf">From LCF to HOL: a short history</a>
  <li id="LCF_HOL_history" class="citation-entry">
    [38]: Mike Gordon (1996)
    <a href="https://www.cl.cam.ac.uk/archive/mjcg/papers/HolHistory.pdf">From LCF to HOL: a short history</a>
  </li>
</ul>
<!-- https://isabelle.in.tum.de/library/HOL/HOL/document.pdf -->
<!-- calculus of inductive constants (in coq)
https://flint.cs.yale.edu/cs428/coq/doc/Reference-Manual006.html -->
</section>
</section>
<section id="suggestions-for-future-work">
<h2><span class="section-number">8.16. </span>Suggestions for Future Work<a class="headerlink" href="#suggestions-for-future-work" title="Permalink to this heading">#</a></h2>
<p>I definitely agree having an explicit chapter on both first-order logic and theorem provers related to FOL would be helpful, especially as a preceding chapter to the current one about higher-order logic and Isabelle. This chapter should also include popular Automatic Theorem Provers (ATPs) for FOL, and could serve as a nice introduction into theorem proving and “stronger” tools such as Isabelle/HOL and Lean.</p>
<p>It might also be interesting to see different chapters covering automatic theorem provers such as Vampire or Satallax vs interactive theorem provers such as Isabelle/HOL or Lean. In addition, there should be a clear division made between first order logic ATPs such as the aforementioned Vampire and higher-order logic ATPs such as Satallax.</p>
<p>It may also be interesting and useful to either create or find an online Isabelle/HOL program that can run in a web browser, similar to the Lean Game Server. This way users can be quickly onboarded to the tool without having to go through download, setup, version compatibility issues, and other miscellaneous problems that may arise.</p>
</section>
<section id="contributors">
<h2><span class="section-number">8.17. </span>Contributors<a class="headerlink" href="#contributors" title="Permalink to this heading">#</a></h2>
<p>Initial Author: Spencer Au</p>
<p>Peer Reviewer: Wayne Chong</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./content"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="9-hoare-logic.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">7. </span>Hoare Logic with Dafny</p>
      </div>
    </a>
    <a class="right-next"
       href="11-dependent-types.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">9. </span>Type Theory with Lean</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#idea-and-introduction">8.1. Idea and Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-theory">8.2. Basic Theory</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-first-order-logic-to-higher-order-logic">8.2.1. From First-Order Logic to Higher-Order Logic</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-hol-type-system">8.2.2. The HOL Type System</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lambda-lambda-abstraction">8.2.3. Lambda (<span class="math notranslate nohighlight">\(\lambda\)</span>) Abstraction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logical-constants-in-hol">8.2.4. Logical Constants in HOL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deductive-core-of-hol">8.2.5. Deductive Core of HOL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tool-installation-first-example-first-exercise">8.3. Tool (Installation, First Example, First Exercise)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#installation">8.3.1. Installation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-solving-via-sledgehammer">8.3.2. Proof Solving via Sledgehammer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-example-add-function">8.3.3. First Example - Add Function</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-exercise-associativity-and-commutativity-of-add">8.3.4. First Exercise - Associativity and Commutativity of Add</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">8.3.5. First Exercise - Associativity and Commutativity of Add</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#intro-example-flattening-and-length-invariant">8.4. Intro Example - Flattening and Length Invariant</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">8.5. Intro Example - Flattening and Length Invariant</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#list-flattening">8.5.1. List Flattening</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#length-invariant">8.5.2. Length Invariant</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">8.5.3. List Flattening</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">8.5.4. Length Invariant</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-landscape-of-tools">8.6. The Landscape of Tools</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interactive-theorem-provers">8.6.1. Interactive Theorem Provers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#automated-theorem-prover">8.6.2. Automated Theorem Prover</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#programming-languages">8.6.3. Programming Languages</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms">8.7. Algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matching-and-unification">8.7.1. Matching and Unification</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simplification-rewriting">8.7.2. Simplification &amp; Rewriting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-search-and-external-automation">8.7.3. Proof Search and External Automation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#typical-use-cases">8.8. Typical Use Cases</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#benchmarks-and-competitions">8.9. Benchmarks and Competitions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-in-industry-and-academia">8.10. Applications in Industry and Academia</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#physical-addressing-on-real-hardware">8.10.1. Physical Addressing on Real Hardware</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#focus-stream-processing-components">8.10.2. FOCUS - Stream Processing Components</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isabil-verifying-in-correctness-of-binaries">8.10.3. IsaBIL - Verifying (In)Correctness of Binaries</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verlso-isolation-guarantees-of-database-transactions">8.10.4. Verlso - Isolation Guarantees of Database Transactions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ieee-754-floating-point-implementation-for-mdps">8.10.5. IEEE 754 Floating Point Implementation for MDPs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#autoformalization-with-large-language-models">8.10.6. Autoformalization with Large Language Models</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#case-study-autoformalization-with-llms">8.11. Case Study - Autoformalization with LLMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">8.12. Case Study - Autoformalization with LLMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#history">8.13. History</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#origins-of-higher-order-logic">8.13.1. Origins of Higher-Order Logic</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#development-of-isabelle-hol">8.13.2. Development of Isabelle/HOL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#current-events-within-isabelle-hol">8.14. Current Events within Isabelle/HOL</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#current-development">8.14.1. Current Development</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#research-challenges">8.14.2. Research Challenges</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conferences-and-workshops">8.14.3. Conferences and Workshops</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">8.15. References</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ebooks-and-textbooks">8.15.1. eBooks and Textbooks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">8.15.2. eBooks and Textbooks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#online-articles">8.15.3. Online Articles</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">8.15.4. Online Articles</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#research-papers">8.15.5. Research Papers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">8.15.6. Research Papers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#videos">8.15.7. Videos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">8.15.8. Videos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#miscellaneous">8.15.9. Miscellaneous</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#suggestions-for-future-work">8.16. Suggestions for Future Work</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#contributors">8.17. Contributors</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By CPSC 510
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>