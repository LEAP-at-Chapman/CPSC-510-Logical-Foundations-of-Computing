

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>9. Type Theory with Lean &#8212; Logical Foundations of Computing</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"Set": ["{\\sf Set}", 0], "Qu": ["{\\Omega}", 0], "QuCat": ["{\\Omega\\text{-cat}}", 0], "One": ["{\\mathbb{1}}", 0], "yo": ["\u3088", 0], "bigsqcap": ["\\sqcap", 0]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'content/09-type-theory-lean';</script>
    <link rel="canonical" href="https://leap-at-chapman.github.io/CPSC-510-Logical-Foundations-of-Computing/content/09-type-theory-lean.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Hoare Logic" href="appendix-hoare-logic.html" />
    <link rel="prev" title="8. Higher-Order Logic with Isabelle" href="08-higher-order-logic-isabelle.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="0-0-title.html">
  
  
  
  
  
  
    <p class="title logo__title">Logical Foundations of Computing</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="0-1-intro-book.html">The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="0-2-intro-logic.html">Big Ideas of Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="0-3-intro-propositional-logic.html">Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="0-4-intro-modal-logic.html">Modal Logic</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Logics and Tools</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01-sat-solving-minisat.html">1. SAT solving with MiniSat</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-logic-programming-prolog.html">2. Logic Programming with Prolog</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-constraints-minizinc.html">3. Constraints with MiniZinc</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-smt-solving-z3.html">4. SMT Solving and Z3</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-temporal-logic-spin.html">5. Temporal Logic with Spin</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-epistemic-logic-smcdel.html">6. Epistemic Logic with SMCDEL</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-hoare-logic-dafny.html">7. Hoare Logic with Dafny</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-higher-order-logic-isabelle.html">8. Higher-Order Logic with Isabelle</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">9. Type Theory with Lean</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="appendix-hoare-logic.html">Hoare Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix-syllogistic-logics.html">Syllogistic Logics in Isabelle</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix-complexity-classes.html">Complexity Classes Overview</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Style Guide</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="how-to-cite.html">How to Cite References</a></li>
<li class="toctree-l1"><a class="reference internal" href="how-to-contribute.html">How to Contribute</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/LEAP-at-Chapman/CPSC-510-Logical-Foundations-of-Computing" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/LEAP-at-Chapman/CPSC-510-Logical-Foundations-of-Computing/issues/new?title=Issue%20on%20page%20%2Fcontent/09-type-theory-lean.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/content/09-type-theory-lean.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Type Theory with Lean</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">9.1. Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#idea">9.2. Idea</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-theory">9.3. Basic Theory</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-curry-howard-correspondence">9.3.1. The Curry-Howard Correspondence</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tool">9.4. Tool</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introductory-examples">9.5. Introductory Examples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logic-game">9.5.1. Logic Game</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#immediate-feedback-loop">9.5.1.1. Immediate Feedback Loop</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-mental-model-of-lean">9.5.1.2. The “Mental Model” of Lean</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#encourages-experimentation">9.5.1.3. Encourages Experimentation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#natural-number-game">9.5.2. Natural Number Game</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#how-mathematics-can-be-built-from-axiom">9.5.2.1. How Mathematics Can Be Built From Axiom</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#inductive-reasoing-through-direct-interaction">9.5.2.2. Inductive Reasoing Through Direct Interaction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#motivates-algorithmic-thinking">9.5.2.3. Motivates Algorithmic Thinking</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-landscape-of-tools">9.6. The Landscape of Tools</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms">9.7. Algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bidirectional-typechecking-type-inference-type-checking-separation">9.7.1. Bidirectional typechecking / type-inference + type-checking separation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equality-normalization-conversion-extensionality-checking">9.7.2. Equality / Normalization / Conversion / Extensionality Checking</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elaboration">9.7.3. Elaboration</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#combined-algorithmic-stack-decidability-trust">9.7.4. Combined algorithmic stack: Decidability + Trust</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#benchmarks-and-competitions">9.8. Benchmarks and Competitions</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-competition-benchmarks">9.8.1. Mathematical Competition Benchmarks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-imo-grand-challenge">9.8.2. The IMO Grand Challenge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classical-automated-theorem-proving-competitions">9.8.3. Classical Automated Theorem Proving Competitions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recent-developments-and-ai-integration">9.8.4. Recent Developments and AI Integration</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-in-industry">9.9. Applications in Industry</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#historical-and-influencial-application">9.9.1. Historical and Influencial Application</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recent-emerging-directions">9.9.2. Recent &amp; Emerging Directions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#case-study">9.10. Case Study</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#history">9.11. History</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#formal-methods-and-ai">9.12. Formal Methods and AI</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#infrastructure-for-ai-driven-theorem-proving">9.12.1. Infrastructure for AI-Driven Theorem Proving</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#retrieval-augmented-language-models">9.12.2. Retrieval-Augmented Language Models</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#integration-with-large-language-models">9.12.3. Integration with Large Language Models</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#challenges-and-future-directions">9.12.4. Challenges and Future Directions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#current-development">9.13. Current Development</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#institutional-support-and-the-lean-fro">9.13.1. Institutional Support and the Lean FRO</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathlib4-development">9.13.2. Mathlib4 Development</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#high-profile-formalization-projects">9.13.3. High-Profile Formalization Projects</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#commercial-and-research-ecosystem">9.13.4. Commercial and Research Ecosystem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recognition-and-future-outlook">9.13.5. Recognition and Future Outlook</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#resources">9.14. Resources</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#future-work">9.15. Future Work</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="type-theory-with-lean">
<h1><span class="section-number">9. </span>Type Theory with Lean<a class="headerlink" href="#type-theory-with-lean" title="Permalink to this heading">#</a></h1>
<p>Author: <em>Khoa Nguyen</em></p>
<section id="introduction">
<h2><span class="section-number">9.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h2>
<p>This chapter presents dependent type theory with Lean, demonstrating how types can depend on values and enabling “proofs as programs” through the Curry-Howard correspondence.</p>
</section>
<section id="idea">
<h2><span class="section-number">9.2. </span>Idea<a class="headerlink" href="#idea" title="Permalink to this heading">#</a></h2>
<p>Dependent Type Theory (DTT) is the idea that types can depend on values. In traditional programming languages, types classify values. <code class="docutils literal notranslate"><span class="pre">Int</span></code> describes integers, <code class="docutils literal notranslate"><span class="pre">Bool</span></code> describes True or False, etc… With dependent type theory, a type itself depends on a value. For example, instead of defining a single <code class="docutils literal notranslate"><span class="pre">array</span></code> type, we define <code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">n</span> <span class="pre">A</span></code>, meaning “an array of length n whose elements are of type A.” This makes certain properties, like the dimension of an array, part of the type system itself. The compiler can then verify these constraints automatically.</p>
<p>This expressiveness blurs the boundary between proofs and programs. In dependent type theory, writing a function that computes something often simultaneously constructs a proof of its correctness. For instance, a function that returns the sum of two natural numbers can be defined alongside a proof that addition is associative or commutative, proofs that Lean, Coq, or Agda can check mechanically.</p>
<p>Dependent Type Theory(DTT) is a unifying foundation for:</p>
<ul class="simple">
<li><p>Formal mathematics where theorems and proofs are treated as typed objects.</p></li>
<li><p>Verified programming where correctness is guaranteed by construction.</p></li>
</ul>
<p>Think of DTT as the language that connects mathematics, logic, and software engineering. It transforms “what is true” into “what is computed” and vice versa.</p>
<p>Dependent Type Theory allows us to design systems in which the structure of code mirrors the structure of mathematics. This is the essence of the proofs-as-programs paradigm: a verified program is not something we write after designing an algorithm; it is the algorithm, expressed in a logical language rich enough to verify itself.</p>
</section>
<section id="basic-theory">
<h2><span class="section-number">9.3. </span>Basic Theory<a class="headerlink" href="#basic-theory" title="Permalink to this heading">#</a></h2>
<p>To understand DTT, we begin by situating it within the broader landscape of type systems and logical foundation.</p>
<p>Type theory originated as an alternative to set theory, most famously through the work of Bertrand Russell and Alonzo Church. The simply typed lambda calculus provided a framework where every term has a type, and functions are first-class citizens. In this setting, a type may be thought of as a “set of allowable values,” and a program as a “proof that a value exists.”</p>
<p>Dependent types generalize this by allowing types to vary depending on terms. Formally, if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a type and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">A</span></code>, then we may form another type <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">a</span></code> that depends on <code class="docutils literal notranslate"><span class="pre">a</span></code>. The dependent function type is then written: <span class="math notranslate nohighlight">\((\Pi x:A),B(x)\)</span> which can be read as “for every <code class="docutils literal notranslate"><span class="pre">x</span></code> of type <code class="docutils literal notranslate"><span class="pre">A</span></code>, there exists a term of type <code class="docutils literal notranslate"><span class="pre">B(x)</span></code>.” This construct generalizes both functions and universal quantification.</p>
<section id="the-curry-howard-correspondence">
<h3><span class="section-number">9.3.1. </span>The Curry-Howard Correspondence<a class="headerlink" href="#the-curry-howard-correspondence" title="Permalink to this heading">#</a></h3>
<p>The Curry-Howard Correspondence underlies DTT, establishing a deep analogy between logic and computation:</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Logic</p></th>
<th class="head"><p>Type Theory</p></th>
<th class="head"><p>Computation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Proposition</p></td>
<td><p>Type</p></td>
<td><p>Specification</p></td>
</tr>
<tr class="row-odd"><td><p>Proof</p></td>
<td><p>Term(program)</p></td>
<td><p>Implementation</p></td>
</tr>
<tr class="row-even"><td><p>Proof normalization</p></td>
<td><p>Term reduction</p></td>
<td><p>Program execution</p></td>
</tr>
</tbody>
</table>
</div>
<p>In this view, proving a proposition corresponds to constructing a program of a certain type.
For example:</p>
<ul class="simple">
<li><p>A proof of <span class="math notranslate nohighlight">\(A \rightarrow B\)</span> corresponds to a function from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p></li>
<li><p>A proof of <span class="math notranslate nohighlight">\(A \land B\)</span> corresponds to a pair <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>.</p></li>
<li><p>A proof of <span class="math notranslate nohighlight">\(A \lor B\)</span> corresponds to either <code class="docutils literal notranslate"><span class="pre">inl</span> <span class="pre">a</span></code> (<code class="docutils literal notranslate"><span class="pre">a</span></code> belongs to left type <code class="docutils literal notranslate"><span class="pre">A</span></code>) or <code class="docutils literal notranslate"><span class="pre">inr</span> <span class="pre">b</span></code>(<code class="docutils literal notranslate"><span class="pre">b</span></code> belongs to right type <code class="docutils literal notranslate"><span class="pre">B</span></code>).</p></li>
</ul>
<p>Dependent types extend this by allowing logical quantification to range over terms, i.e. a function’s return type can be determined by the value of its input, rather than just its type. Thus, “for every <code class="docutils literal notranslate"><span class="pre">n</span></code>, there exists a vector of length <code class="docutils literal notranslate"><span class="pre">n</span></code> sorted in ascending order” can be written as a dependent function type.</p>
<p>The Curry-Howard correspondence unifies programming, mathematics, and logic into a single framework: to prove is to program.</p>
</section>
</section>
<section id="tool">
<h2><span class="section-number">9.4. </span>Tool<a class="headerlink" href="#tool" title="Permalink to this heading">#</a></h2>
<p>The following installation is pulled directly from the official Lean installation instructions - <a class="reference external" href="https://lean-lang.org/install/">“Install Lean”</a></p>
<ul class="simple">
<li><p>Install VS Code</p></li>
<li><p>Install the official Lean 4 extension in VS Code</p></li>
<li><p>Complete the extension by following the guideline of Lean 4 extension:</p>
<ul>
<li><p>Click the “<span class="math notranslate nohighlight">\(\forall\)</span>” symbol at the top right of the window.</p></li>
<li><p>Hover down to “Documentation…”</p></li>
<li><p>Click on “Show Setup Guide”</p></li>
<li><p>Follow the guide until “Install Lean” option light up</p></li>
<li><p>Click “Install Lean”</p></li>
</ul>
</li>
</ul>
<p>To verify that the installation is successful, create a <code class="docutils literal notranslate"><span class="pre">test.lean</span></code> file and enter the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">#eval</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">id</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#eval</span> <span class="pre">Lean.versionString</span></code></p></li>
</ul>
<p>One sign that Lean has been installed correctly is that <code class="docutils literal notranslate"><span class="pre">#eval</span></code> and <code class="docutils literal notranslate"><span class="pre">#check</span></code> turn blue. A screen called <code class="docutils literal notranslate"><span class="pre">Lean</span> <span class="pre">InfoView</span></code> appeared with the appropriate results.</p>
</section>
<section id="introductory-examples">
<h2><span class="section-number">9.5. </span>Introductory Examples<a class="headerlink" href="#introductory-examples" title="Permalink to this heading">#</a></h2>
<p>One of the most effective ways to begin learning Lean is through the <a class="reference external" href="https://adam.math.hhu.de/">Lean Game Server</a>. These games remove setup overhead, eliminate the intimidation factor of reading large formal libraries, and instead invite learners to explore Lean through hands-on examples. Two of the most valuable games for beginners are the <a class="reference external" href="https://adam.math.hhu.de/#/g/trequetrum/lean4game-logic">Logic Games</a> and the <a class="reference external" href="https://adam.math.hhu.de/#/g/leanprover-community/nng4">Natural Number Games</a>. Both games illustrate the power of formal methods in a setting that is playful and intellectually rigorous.</p>
<section id="logic-game">
<h3><span class="section-number">9.5.1. </span>Logic Game<a class="headerlink" href="#logic-game" title="Permalink to this heading">#</a></h3>
<p>The Logic Game introduces users to the foundational rules of formal logic such as implication, negation, conjunction, disjunction, quantifiers, etc… through short, progressively challenging proof puzzles. Its educational value comes from several key features:</p>
<section id="immediate-feedback-loop">
<h4><span class="section-number">9.5.1.1. </span>Immediate Feedback Loop<a class="headerlink" href="#immediate-feedback-loop" title="Permalink to this heading">#</a></h4>
<p>Unlike traditional textbooks, the Logic Game responds instantly to every tactic command:</p>
<ul class="simple">
<li><p>If a tactic is correct, Lean advances the goal state.</p></li>
<li><p>If a tactic is wrong, Lean explains why.</p></li>
</ul>
<p>This tight feedback loop mirrors the experience of interacting with an automated proof assistant in real industrial or research settings, lowering the learning curve dramatically.</p>
</section>
<section id="the-mental-model-of-lean">
<h4><span class="section-number">9.5.1.2. </span>The “Mental Model” of Lean<a class="headerlink" href="#the-mental-model-of-lean" title="Permalink to this heading">#</a></h4>
<p>The Logic Game is explicitly designed to teach users how Lean thinks about logic:</p>
<ul class="simple">
<li><p>Every tactic corresponds to a precise logical rule.</p></li>
<li><p>Users see how Lean’s kernel enforces correctness step by step.</p></li>
</ul>
<p>This builds intuition for dependent type theory and Curry–Howard correspondence (propositions-as-types), but without requiring the learner to know any theory beforehand.</p>
</section>
<section id="encourages-experimentation">
<h4><span class="section-number">9.5.1.3. </span>Encourages Experimentation<a class="headerlink" href="#encourages-experimentation" title="Permalink to this heading">#</a></h4>
<p>Players can try tactics freely without risk. This experimentation fosters:</p>
<ul class="simple">
<li><p>pattern recognition</p></li>
<li><p>tactical reasoning</p></li>
<li><p>an understanding of proof search strategies</p></li>
</ul>
<p>These habits carry directly over to real software verification tasks.</p>
</section>
</section>
<section id="natural-number-game">
<h3><span class="section-number">9.5.2. </span>Natural Number Game<a class="headerlink" href="#natural-number-game" title="Permalink to this heading">#</a></h3>
<p>The Natural Number Game (NNG) has become one of the most popular introductions to Lean worldwide. The educational value stems from how it blends mathematics, computation, and logic.</p>
<p>You will prove fundamental facts such as <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">!=</span> <span class="pre">succ</span> <span class="pre">n</span></code>, addition is associative and commutative, <code class="docutils literal notranslate"><span class="pre">succ</span></code> is injective, multiplication distributes over addition, etc…</p>
<section id="how-mathematics-can-be-built-from-axiom">
<h4><span class="section-number">9.5.2.1. </span>How Mathematics Can Be Built From Axiom<a class="headerlink" href="#how-mathematics-can-be-built-from-axiom" title="Permalink to this heading">#</a></h4>
<p>Students are often familiar with these results from prior coursework, but they rarely see how foundational proofs look at the axiomatic level. The NNG demonstrates:</p>
<ul class="simple">
<li><p>How definitions induce computation rules</p></li>
<li><p>How to manipulate inductive types</p></li>
<li><p>How recursion and induction arise naturally</p></li>
</ul>
<p>This concreteness demystifies dependent type theory: users experience how a simple inductive type gives rise to a rich structure.</p>
</section>
<section id="inductive-reasoing-through-direct-interaction">
<h4><span class="section-number">9.5.2.2. </span>Inductive Reasoing Through Direct Interaction<a class="headerlink" href="#inductive-reasoing-through-direct-interaction" title="Permalink to this heading">#</a></h4>
<p>Induction is not merely stated, it is performed repeatedly. Lean forces the user to spell out base cases, induction hypotheses, goals and recursive patterns. This active engagement builds intuition for how proof assistants handle recursion and induction, which are core tools in both mathematics and formal verification.</p>
</section>
<section id="motivates-algorithmic-thinking">
<h4><span class="section-number">9.5.2.3. </span>Motivates Algorithmic Thinking<a class="headerlink" href="#motivates-algorithmic-thinking" title="Permalink to this heading">#</a></h4>
<p>Because natural number definitions are computational, players quickly see how rewriting works, pattern matching influences evaluation, recursive structures behave algorithmically. This bridges the gap between formal mathematics and computer science practice, showing why proof assistants can serve as both logical frameworks and programming languages.</p>
</section>
</section>
</section>
<section id="the-landscape-of-tools">
<h2><span class="section-number">9.6. </span>The Landscape of Tools<a class="headerlink" href="#the-landscape-of-tools" title="Permalink to this heading">#</a></h2>
<p>This section presents a landscape view of major tools in the DTT ecosystem as of 2025. It will breakdown their design trade-offs, typical use-cases, and relative strengths or weaknesses.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Tool/Language</p></th>
<th class="head"><p>Description &amp; Strengths</p></th>
<th class="head"><p>Typical Use Cases / Trade-offs</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Lean (Lean 4 + mathlib)</p></td>
<td><p>A modern proof assistant + functional programming language based on dependent types (Calculus of Constructions + inductives + universes). Offers a powerful elaboration engine, a small trusted kernel, fast incremental compilation, and support for both interactive tactics and functional proof style.</p></td>
<td><p>Great for formal mathematics, verified algorithms, interactive theorem proving, and even practical verification tasks. Its large community and active library (mathlib) make it a go-to for general-purpose verification or mathematics.</p></td>
</tr>
<tr class="row-odd"><td><p>Coq</p></td>
<td><p>One of the oldest and most widely used proof assistants based on DTT (or similar). Supports extraction to programming languages, large body of existing formalization (math, compilers, verified software), powerful tactic languages.</p></td>
<td><p>Best for verified software projects, certified compilers (e.g. CompCert), verified algorithms, and academic formalization. Has a steep learning curve, sometimes verbose proof scripts, and a heavier kernel than simpler languages.</p></td>
</tr>
<tr class="row-even"><td><p>Agda</p></td>
<td><p>A dependently typed programming language/proof assistant more in the “programming + proof as functional style” camp (rather than tactic-based). Similar to MLTT tradition, with strong emphasis on inductive families, totality, and interactive evaluation.</p></td>
<td><p>Good for experimental formalizations, teaching type theory, writing dependently typed programs. More suited for small-to-medium proofs; less focused on industrial-scale verification or large libraries.</p></td>
</tr>
<tr class="row-odd"><td><p>Idris / Idris 2</p></td>
<td><p>A dependently typed programming language with a focus on general-purpose programming, not only proof. Supports effects, code generation (e.g. C, JS), totality checking or partial functions depending on settings.</p></td>
<td><p>Good when you want a language with expressive types and runtime code generation for building verified-but-executable programs. Less mature than proof assistants; less library support; proofs may be more manual.</p></td>
</tr>
<tr class="row-even"><td><p>Haskell</p></td>
<td><p>A general-purpose, functional programming language that is statically typed with type inference and lazy evaluation. Popular in academia and industry</p></td>
<td><p>It has practical, industrial-strength functional programming and powerful abstractions, rich ecosystem, compilers (GHC) with pluggable extensions. Typically used in high-assurance and mission-critical systems, data transformation pipelines, and systems that benefit from strong static guarantees. It has a steep learning curve; unpredictable performance due to laziness; smaller ecosystem; harder hiring pipeline; abstract debugging; less ergonomic for low-level systems</p></td>
</tr>
</tbody>
</table>
</div>
<p>When selecting among tools, you should weigh:</p>
<ul class="simple">
<li><p>Expressiveness vs. automation: More expressive systems (Lean, Coq, Agda, Idris) allow rich invariants and proofs but often need manual proof work. Automated or SMT-backed tools trade expressiveness for easier automation.</p></li>
<li><p>Library / ecosystem maturity: Tools like Lean (with mathlib) or Coq have large libraries, others are more experimental. A rich library reduces the need to build basic building blocks from scratch.</p></li>
<li><p>Executable code vs. proof-only: Some tools (Idris, Lean) allow writing code that runs, while also proving properties. Others often focus on proofs and not on extracting executable code, or else code extraction is more ad-hoc.</p></li>
<li><p>User experience / ergonomics: Elaborators, tactic languages, and proof modes dramatically affect productivity. For example, Lean’s elaboration engine is a major advantage for usability.</p></li>
<li><p>Scalability / maintenance: For large projects, proof maintenance, library design, and modularization become critical. Tools that facilitate factoring, code reuse, automation or tactic writing tend to scale better for big verifications.</p></li>
</ul>
</section>
<section id="algorithms">
<h2><span class="section-number">9.7. </span>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this heading">#</a></h2>
<p>In implementing and using a dependently typed language or proof assistant (like Lean, Coq, Agda, Idris, etc.), a number of non-trivial algorithms lie at the foundation. These algorithms handle typing, type checking and inference, equality checking, unification or normalization, and elaboration. Understanding them gives insight into why dependent types are powerful and why they present unique computational challenges. This section examines the key algorithmic components that make modern dependent type theory systems both powerful and practical.</p>
<section id="bidirectional-typechecking-type-inference-type-checking-separation">
<h3><span class="section-number">9.7.1. </span>Bidirectional typechecking / type-inference + type-checking separation<a class="headerlink" href="#bidirectional-typechecking-type-inference-type-checking-separation" title="Permalink to this heading">#</a></h3>
<p>Instead of trying to infer types for all expressions (type inference) or requiring full type annotations everywhere, bidirectional typing splits the typing judgment into two modes:</p>
<ol class="arabic simple">
<li><p>Synthesis (or inference): from a term <code class="docutils literal notranslate"><span class="pre">t</span></code>, compute (synthesize) a type <code class="docutils literal notranslate"><span class="pre">A</span></code>, written informally <span class="math notranslate nohighlight">\(t \Rightarrow A\)</span>.</p></li>
<li><p>Checking: given a term <code class="docutils literal notranslate"><span class="pre">t</span></code> and a desired type <code class="docutils literal notranslate"><span class="pre">A</span></code>, check that <code class="docutils literal notranslate"><span class="pre">t</span></code> indeed has type <code class="docutils literal notranslate"><span class="pre">A</span></code>, written <span class="math notranslate nohighlight">\(t \Leftarrow A\)</span>.</p></li>
</ol>
<p>This matters because full type inference in a dependently typed setting tends to be undecidable or requires heavy annotation, due to types themselves may depend on values. By adopting a bidirectional discipline, one can recover a decidable, predictable algorithmic core for a large class of dependent type theories. <a class="reference external" href="https://scholar.google.com/scholar?q=Generic+bidirectional+typing+for+dependent+type+theories+Felicissimo">Generic bidirectional typing for dependent type theories</a> (Felicissimo et al., 2024) paper gives a generic account of bidirectional typing for a wide class of dependent type theories, showing that for many theories, a sound and complete bidirectional checker can be derived.</p>
<p>The generic construction yields a type-checking algorithm for a broad class of DTTs, implemented in a prototype tool. This ensures that the type checker for a dependently typed language can remain decidable (under suitable normalization/termination assumptions) while supporting expressive dependent types.</p>
<p>The necessity of type annotations in places where inference is impossible (e.g., lambda abstractions returning dependent types, complex implicit arguments). The complexity of designing good elaboration strategies so that user-facing syntax remains ergonomic even when underlying types are rich and dependent. The burden shifts from runtime safety to compile-time/type-check-time; the user (or tool) must supply sufficient information for checking.</p>
</section>
<section id="equality-normalization-conversion-extensionality-checking">
<h3><span class="section-number">9.7.2. </span>Equality / Normalization / Conversion / Extensionality Checking<a class="headerlink" href="#equality-normalization-conversion-extensionality-checking" title="Permalink to this heading">#</a></h3>
<p>In dependent type theory, type equality (and term equality) is not just “are they syntactically identical?”. It often involves computation (normalization), conversion rules (<span class="math notranslate nohighlight">\(\beta\)</span>-reduction), and user-defined equality/extension rules (e.g., extensionality, definitional equalities). Implementations need an algorithm to decide or check when two types or terms are equal.</p>
<p>The paper <a class="reference external" href="https://scholar.google.com/scholar?q=An+extensible+equality+checking+algorithm+for+dependent+type+theories+Bauer+Komel">“An extensible equality checking algorithm for dependent type theories”</a> (Bauer and Komel, 2022) introduces a general algorithm combining type-directed extensionality rules with normalization by computation rules, and shows how to classify rules as computational or extensional in a user-definable way. The algorithm is implemented in a proof assistant prototype that supports custom dependent type theories.</p>
<p>Without a robust equality/normalization algorithm, dependent types, especially those involving dependent functions or indexed types,become unwieldy. Many trivial-looking equalities (e.g., rewriting with definitional reduction, simplification) would need to be proven manually. A good algorithm reduces overhead and makes proofs manageable.</p>
</section>
<section id="elaboration">
<h3><span class="section-number">9.7.3. </span>Elaboration<a class="headerlink" href="#elaboration" title="Permalink to this heading">#</a></h3>
<p>In proof assistants or dependently typed languages, users write code in a friendly high-level syntax (with type annotations optional, implicit arguments, etc.). The elaboration phase translates that syntax into the core type theory: resolves implicit arguments, performs type inference/checking, adds coercions, resolves overloading, etc.</p>
<p>Elaboration is an overloaded term in Lean. It can refer both to the overall process of translating high-level syntax to core expressions and to the specific process of taking a partially-specified expression and inferring what is left implicit (Lean Community, n.d.). When users enter expressions like <code class="docutils literal notranslate"><span class="pre">λ</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z,</span> <span class="pre">f</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">z</span></code>, they leave information implicit: types must be inferred from context, overloaded notation must be resolved, and implicit arguments need to be filled in.</p>
<p>The elaboration process involves several distinct phases. During parsing, Lean matches strings of code to declared syntax rules to produce <code class="docutils literal notranslate"><span class="pre">Syntax</span></code> objects, after which macros transform <code class="docutils literal notranslate"><span class="pre">Syntax</span></code> into new <code class="docutils literal notranslate"><span class="pre">Syntax</span></code> recursively until no more macros apply (Lean Community, n.d.). Finally, the system finds an elaborator matched to the appropriate syntax rule that returns an <code class="docutils literal notranslate"><span class="pre">Expr</span></code> object, completing the elaboration step before the expression is converted to executable code during evaluation.</p>
<p>Without a powerful elaboration engine, users would face the burden of writing explicit dependent types everywhere. Good elaboration makes dependent typing practical by hiding complexity while retaining formal guarantees. As the Lean developers emphasize, the combination of a powerful elaboration engine, a small trusted kernel, and support for mixed declarative and tactic proof styles makes Lean a mature system for real-world development.</p>
</section>
<section id="combined-algorithmic-stack-decidability-trust">
<h3><span class="section-number">9.7.4. </span>Combined algorithmic stack: Decidability + Trust<a class="headerlink" href="#combined-algorithmic-stack-decidability-trust" title="Permalink to this heading">#</a></h3>
<p>The integration of bidirectional typing, equality checking through normalization, elaboration, and a small trusted kernel yields a system where:</p>
<ul class="simple">
<li><p><strong>Type checking and proof checking remain decidable</strong> (modulo normalization and termination constraints), ensuring that verification terminates</p></li>
<li><p><strong>User code stays readable and ergonomic</strong>, with implicit arguments and convenient notation resolved automatically</p></li>
<li><p><strong>Proof objects are small and checkable</strong> by a trusted kernel, providing strong correctness guarantees</p></li>
<li><p><strong>Automation builds naturally on top</strong>, with tactics, decision procedures, and AI-assisted reasoning extending the core system</p></li>
</ul>
<p>This algorithmic backbone enables modern dependent type theory-based proof assistants to scale from toy examples to libraries containing hundreds of thousands of formalized theorems. The careful balance between decidability, expressiveness, and usability represents decades of research in type theory, programming languages, and automated reasoning.</p>
</section>
</section>
<section id="benchmarks-and-competitions">
<h2><span class="section-number">9.8. </span>Benchmarks and Competitions<a class="headerlink" href="#benchmarks-and-competitions" title="Permalink to this heading">#</a></h2>
<p>The development of dependent type theory systems, particularly Lean, has been significantly shaped by various benchmarks and competitions that provide standardized evaluation frameworks for automated theorem proving and mathematical reasoning. These benchmarks serve multiple purposes: they enable objective comparison of different systems and approaches, drive progress in the field, and establish concrete goals for researchers working on AI-assisted theorem proving.</p>
<section id="mathematical-competition-benchmarks">
<h3><span class="section-number">9.8.1. </span>Mathematical Competition Benchmarks<a class="headerlink" href="#mathematical-competition-benchmarks" title="Permalink to this heading">#</a></h3>
<p>One of the most influential benchmarks in the theorem proving community is <strong>miniF2F</strong> (mini Formal-to-Formal), introduced by Zheng, Han, and Polu in 2021. This cross-system benchmark consists of 488 formal mathematical problem statements drawn from the American Invitational Mathematics Examination (AIME), American Mathematics Competitions (AMC), and the International Mathematical Olympiad (IMO), as well as material from high-school and undergraduate mathematics courses (Zheng et al., 2021). The benchmark targets multiple proof assistants including Lean, Metamath, Isabelle, and HOL Light, making it particularly valuable for comparing systems across different foundations. Problems are divided into validation and test sets of 244 problems each, allowing researchers to tune their systems while maintaining held-out data for final evaluation.</p>
<p>Building on miniF2F, researchers have developed more specialized benchmarks. The LeanGeo benchmark, introduced in 2025, comprises 122 geometry problems including all IMO geometry problems since 2000, providing the first formalized geometric problem benchmark in Lean 4 with human-readable proofs (Team et al., 2025). PutnamBench presents problems from the William Lowell Putnam Mathematical Competition and is notable for supporting Lean 4, Isabelle, and Coq, representing undergraduate-level mathematics of considerable difficulty (Tsoukalas et al., 2024).</p>
<p>For research-level mathematics, ProofNet provides 371 examples of undergraduate-level pure mathematics, each consisting of a formal theorem statement in Lean 3, a natural language statement, and a natural language proof. The problems span real and complex analysis, linear algebra, abstract algebra, and topology, creating a bridge between competition mathematics and university coursework (Azerbayev et al., 2023).</p>
</section>
<section id="the-imo-grand-challenge">
<h3><span class="section-number">9.8.2. </span>The IMO Grand Challenge<a class="headerlink" href="#the-imo-grand-challenge" title="Permalink to this heading">#</a></h3>
<p>Perhaps the most ambitious goal in automated mathematical reasoning is the <strong>IMO Grand Challenge</strong>, which aims to build an AI system capable of winning a gold medal at the International Mathematical Olympiad. The formal-to-formal variant of this challenge requires the AI to receive problems in formal Lean representation and produce machine-checkable proofs within specified time constraints (IMO Grand Challenge, n.d.). This challenge has inspired significant research and development efforts.</p>
<p>In 2024, Google DeepMind achieved a major milestone when their AlphaProof and AlphaGeometry 2 systems solved four out of six problems from the IMO 2024, earning 28 out of 42 points and achieving silver-medal-level performance (Google DeepMind, 2024). AlphaProof uses reinforcement learning to train itself to prove mathematical statements in Lean, coupling a pre-trained language model with the AlphaZero algorithm. In 2025, progress continued with an advanced version of Gemini Deep Think achieving gold-medal-level performance by solving five out of six IMO problems and earning 35 points (Google DeepMind, 2025).</p>
<p>The FIMO (Formal IMO) dataset contains 149 IMO-level challenging formal statements in Lean along with corresponding informal statements and proofs, specifically targeting the difficulty level that makes the IMO Grand Challenge so formidable (Liu et al., 2023).</p>
</section>
<section id="classical-automated-theorem-proving-competitions">
<h3><span class="section-number">9.8.3. </span>Classical Automated Theorem Proving Competitions<a class="headerlink" href="#classical-automated-theorem-proving-competitions" title="Permalink to this heading">#</a></h3>
<p>While much recent attention has focused on interactive theorem provers like Lean, the field has a longer tradition of competitions for fully automated systems. The CADE ATP System Competition (CASC) is the annual evaluation of fully automatic, classical logic automated theorem proving systems, held at each Conference on Automated Deduction (CADE) and International Joint Conference on Automated Reasoning (IJCAR) (Sutcliffe, 2016). First held in 1996 at Rutgers University, CASC evaluates systems for first-order and higher-order classical logic, providing standardized problem sets and time constraints for objective comparison.</p>
<p>CASC differs fundamentally from benchmarks focused on interactive theorem provers: it targets systems that operate without human guidance, using resolution, superposition, and other automated reasoning techniques. The competition has driven development of systems like E, Vampire, and SETHEO, which excel at different problem classes within first-order logic.</p>
</section>
<section id="recent-developments-and-ai-integration">
<h3><span class="section-number">9.8.4. </span>Recent Developments and AI Integration<a class="headerlink" href="#recent-developments-and-ai-integration" title="Permalink to this heading">#</a></h3>
<p>The landscape of benchmarks continues to evolve with advances in large language models and AI-assisted proving. Recent work has introduced ProverBench, a collection of 325 formalized problems including problems from the 2024-2025 American Invitational Mathematics Examination (DeepSeek, 2025). The FATE-M (Formal Algebra Theorem Evaluation-Medium) benchmark focuses on graduate-level abstract algebra, testing systems on advanced algebraic structures such as groups, rings, and fields.</p>
<p>These benchmarks have revealed both progress and remaining challenges. State-of-the-art systems achieve success rates ranging from approximately 24% on ProofNet to 57% on specialized benchmarks like FATE-M, indicating substantial room for improvement (Wang et al., 2025). The gap between performance on curated benchmarks and research-level mathematics remains significant, highlighting the continued need for advances in automated reasoning, proof search strategies, and integration of formal and informal mathematical knowledge.</p>
</section>
</section>
<section id="applications-in-industry">
<h2><span class="section-number">9.9. </span>Applications in Industry<a class="headerlink" href="#applications-in-industry" title="Permalink to this heading">#</a></h2>
<p>In recent years, formally grounded methods for specifying and verifying software and hardware systems have undergone significant uptake. The combination of dependable “symbolic” reasoning, (i.e. logic, type-theory, theorem-proving, etc…) with the explosion of AI-driven development like machine learning, generative models, is opening up new directions for improvements. Here are briefs summaries of recent influential applications.</p>
<section id="historical-and-influencial-application">
<h3><span class="section-number">9.9.1. </span>Historical and Influencial Application<a class="headerlink" href="#historical-and-influencial-application" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Tokeneer ID Station (NSA smart-card project) is one of the early industrial successes of the “Correctness by Construction” methodology. The case is described by Janet Barnes in <a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=Experiences+in+the+Industrial+use+of+Formal+Methods&amp;btnG=">“Experiences in the Industrial use of Formal Methods”</a>. This article reports on industrial deployment of formal methods under the “Correctness by Construction (CbyC)” approach at Altran Praxis, including the case of the Tokeneer ID Station project for the US NSA. The work describes how formal specification in Z, refinement to code in SPARK with proof of absence of run-time errors, and proof of system-level properties were applied. The project found only five errors post-release and is cited as a rare “success story” of formal methods in industry. The article also candidly discusses challenges: training, tool usability, industrial adoption, and scaling.</p></li>
<li><p><a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=%E2%80%9CSymbolic+QED+Pre-silicon+Verification+for+Automotive+Microcontroller+Cores%3A+Industrial+Case+Study.%E2%80%9D&amp;btnG=">“Symbolic QED Pre-silicon Verification for Automotive Microcontroller Cores: Industrial Case Study”</a> presents an industrial case study applying the “Symbolic Quick Error Detection (Symbolic QED)” technique in the pre-silicon verification of automotive microcontroller cores (~1,800 flip-flops, ~70,000 logic gates). Symbolic QED detected all logic bugs found by previous industrial verification flows, plus additional ones. It significantly reduced verification effort (e.g., an 8× reduction for a new design, and up to ~60× for subsequent designs). Runtime of bug detection improved dramatically (20 seconds or less) with short counterexamples (≤10 instructions).</p></li>
<li><p><a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=Formal+methods+in+dependable+systems+engineering%3A+a+survey+of+professionals+from+Europe+and+North+America&amp;btnG=">“Formal methods in dependable systems engineering: a survey of professionals from Europe and North America”</a> presents survey results from mission-critical software engineering practitioners, investigating how they use formal methods, their intentions to use them, and perceived challenges. Intrinsic motivation drives use more than regulation. Experienced practitioners plan to use more extensively. Major obstacles remain such as: scalability, skills, education, process compatibility, tool reputation. The survey highlights that despite promising case studies, broad industrial adoption remains constrained.</p></li>
<li><p><a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=%E2%80%9CIndustrial-Strength+Verification+of+Solid+State+Interlocking+Programs.%E2%80%9D&amp;btnG=">“Industrial-Strength Verification of Solid State Interlocking Programs”</a> describes a tool used on 26 real-world interlockings and used to augment existing testing/inspection processes. It describes an end-to-end workflow that consumes engineering artefacts as produced by signalling designers, automatically encodes safety properties, runs automated theorem provers and SMT solvers, then produces diagnostics so the results are actionable.</p></li>
</ul>
</section>
<section id="recent-emerging-directions">
<h3><span class="section-number">9.9.2. </span>Recent &amp; Emerging Directions<a class="headerlink" href="#recent-emerging-directions" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>The paper <a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=%E2%80%9CMachine+learning+and+logic%3A+a+new+frontier+in+artificial+intelligence.%E2%80%9D&amp;btnG=">“Machine learning and logic: a new frontier in artificial intelligence”</a> shows how ML/AI and formal methods (logic, automated reasoning) are increasingly tightly coupled. Both foundational pillars have largely developed independently, but novel and grand challenges demand their integration. The authors identify three key paradigms:</p>
<ol class="arabic simple">
<li><p>Using learning methods for proof-rule selection, solver heuristic and initialization.</p></li>
<li><p>Combining inductive learning and deductive reasoning for programming-by-example, synthesis, and verification.</p></li>
<li><p>Using solver feedback as corrective layers for ML models to improve accuracy, generalizability and trustworthiness.
They posit that this convergent direction will have major impact on future AI and verification.</p></li>
</ol>
</li>
<li><p><a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=%E2%80%9CApplication+of+AI+to+formal+methods+%E2%80%94+an+analysis+of+current+trends.%E2%80%9D&amp;btnG=">“Application of AI to formal methods — an analysis of current trends”</a> is a systematic mapping of how AI techniques (including generative models) are being applied to formal methods (and vice versa). It charts emerging directions such as automated invariant generation via ML, proof-assistant tactic synthesis using neural networks, and formal verification of AI/ML system themselves. The analysis highlights both promise of increased automation and reduced annotation and caution.</p></li>
<li><p>Special issue <a class="reference external" href="https://scholar.google.com/scholar?q=%E2%80%9CFormal+Methods+for+Industrial+Critical+Systems%E2%80%9D&amp;hl=en&amp;as_sdt=0%2C5&amp;as_ylo=2024&amp;as_yhi=">“Formal Methods for Industrial Critical Systems”</a> compiles recent tools and experience reports from industry/critical systems. The issue contributions cover a range of domains and emphasize the needs of improving formal tools and publishing empirical experience showing how formal methods integrate with industrial processes.</p></li>
<li><p><a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;as_ylo=2024&amp;q=%22VeriBench%3A+End-to-End+formal+verification+benchmark+for+AI+code+generation+in+Lean+4%22&amp;btnG=">VeriBench: End-to-End Formal Verification Benchmark for AI Code Generation in Lean</a> presents a benchmark suite called VeriBench, designed to evaluate how well large language models (LLMs) can generate complete formal verification artifacts in Lean 4. The experiments show that current frontier LLMs compile and pass only a small fraction of these tasks out of the box. It explicitly highlights how Lean 4’s dependent-type system enables encoding deep invariants. The authors argue
that such benchmarks are essential to meaningful progress in automated code verification &amp; provably correct code generation, especially as generative AI becomes more widely used in software engineering.</p></li>
</ul>
</section>
</section>
<section id="case-study">
<h2><span class="section-number">9.10. </span>Case Study<a class="headerlink" href="#case-study" title="Permalink to this heading">#</a></h2>
<p>Let’s formalise and verify a transformation pipline for 3-D points in world space. Let’s look at a small example where we perform a rotation in place, follow by a translation (moving the point to a different coordinate). This case study will show how dependent types and theorem proving is utilized in computer graphics, like graphical engines utilized in games, movies, animation, etc…</p>
<p>The following case study demonstrates how Lean uses dependent type system to ensures mathematical and computational correctness. By encoding vector dimensions in types and proving geometric invariants such as norm preservation, we move from abstract theory to executable verification. This approach mirrors how formal methods are being integratated into the wider industry.</p>
<p>To initialize a Lean project, run the following line:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>lake<span class="w"> </span>new<span class="w"> </span>my_project<span class="w"> </span>math
</pre></div>
</div>
<p>Feel free to replace <code class="docutils literal notranslate"><span class="pre">my_project</span></code> with any name.</p>
<p><strong>3D Point Transformation Pipeline</strong>
This module demonstrates how dependent types and theorem proving can be used
to verify geometric transformations in computer graphics applications.</p>
<p>We implement:</p>
<ul class="simple">
<li><p>3D vectors with dimension encoded in the type system</p></li>
<li><p>Rotation matrices (orthogonal transformations)</p></li>
<li><p>Translation operations</p></li>
<li><p>A transformation pipeline that composes rotation and translation</p></li>
<li><p>Formal proofs of geometric invariants (norm preservation)</p></li>
</ul>
<p>We declared the structures for 3D points, the rotation matrix and the translation matrix. Each elements of each structures is of type Real numbers.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">Graphics3D</span>

<span class="sd">/-- A 3D point represented as three real coordinates -/</span>
<span class="kd">structure</span><span class="w"> </span><span class="n">Point3D</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>

<span class="sd">/-- A 3x3 rotation matrix -/</span>
<span class="kd">structure</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="n">m00</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m01</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m02</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m10</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m11</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m12</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m20</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m21</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">m22</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>

<span class="sd">/-- A translation vector -/</span>
<span class="kd">structure</span><span class="w"> </span><span class="n">Translation</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="n">dx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">dy</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
<span class="w">  </span><span class="n">dz</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span>
</pre></div>
</div>
<p>We defined below some common formulas and transformation matrixes that will be used to verify our theorems later.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/-- Apply a rotation matrix to a 3D point -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">(</span><span class="n">R</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">,</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">,</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="o">}</span>

<span class="sd">/-- Apply a translation to a 3D point -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Translation</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">t.dx</span><span class="o">,</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">t.dy</span><span class="o">,</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">t.dz</span><span class="w"> </span><span class="o">}</span>

<span class="sd">/-- Compute the squared norm (length squared) of a 3D point -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">normSquared</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span>

<span class="sd">/-- Compute the norm (length) of a 3D point -/</span>
<span class="kd">noncomputable</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">norm</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">Real.sqrt</span><span class="w"> </span><span class="o">(</span><span class="n">normSquared</span><span class="w"> </span><span class="n">p</span><span class="o">)</span>

<span class="sd">/-- A rotation matrix is orthogonal if its columns form an orthonormal basis.</span>
<span class="sd">    This is a key property that ensures rotations preserve distances. -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">isOrthogonal</span><span class="w"> </span><span class="o">(</span><span class="n">R</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="c1">-- Column 1 · Column 1 = 1</span>
<span class="w">  </span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m00</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">∧</span>
<span class="w">  </span><span class="c1">-- Column 2 · Column 2 = 1</span>
<span class="w">  </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">∧</span>
<span class="w">  </span><span class="c1">-- Column 3 · Column 3 = 1</span>
<span class="w">  </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">∧</span>
<span class="w">  </span><span class="c1">-- Column 1 · Column 2 = 0</span>
<span class="w">  </span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">∧</span>
<span class="w">  </span><span class="c1">-- Column 1 · Column 3 = 0</span>
<span class="w">  </span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">∧</span>
<span class="w">  </span><span class="c1">-- Column 2 · Column 3 = 0</span>
<span class="w">  </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span>

<span class="sd">/-- The identity rotation (no rotation) -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">identityRotation</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">m00</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">m01</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">m02</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span>
<span class="w">    </span><span class="n">m10</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">m11</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">m12</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span>
<span class="w">    </span><span class="n">m20</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">m21</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">m22</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">}</span>

<span class="sd">/-- Rotation around the Z-axis by angle θ (in the XY plane) -/</span>
<span class="kd">noncomputable</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">rotationZ</span><span class="w"> </span><span class="o">(</span><span class="n">θ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">m00</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Real.cos</span><span class="w"> </span><span class="n">θ</span><span class="o">,</span><span class="w"> </span><span class="n">m01</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">-</span><span class="n">Real.sin</span><span class="w"> </span><span class="n">θ</span><span class="o">,</span><span class="w"> </span><span class="n">m02</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span>
<span class="w">    </span><span class="n">m10</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Real.sin</span><span class="w"> </span><span class="n">θ</span><span class="o">,</span><span class="w"> </span><span class="n">m11</span><span class="w"> </span><span class="o">:=</span><span class="w">  </span><span class="n">Real.cos</span><span class="w"> </span><span class="n">θ</span><span class="o">,</span><span class="w"> </span><span class="n">m12</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span>
<span class="w">    </span><span class="n">m20</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w">           </span><span class="n">m21</span><span class="w"> </span><span class="o">:=</span><span class="w">  </span><span class="mi">0</span><span class="o">,</span><span class="w">          </span><span class="n">m22</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">}</span>

<span class="sd">/-- A transformation pipeline that first rotates, then translates -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">transformPipeline</span><span class="w"> </span><span class="o">(</span><span class="n">R</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Translation</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">translate</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">(</span><span class="n">rotate</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="n">p</span><span class="o">)</span>
</pre></div>
</div>
<p>We now define our theorems to verify the integrity of our 3D points after applying Rotation and Transformation.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/--</span>
<span class="sd">THEOREM: Orthogonal transformations preserve the squared norm.</span>
<span class="sd">This is a fundamental property in computer graphics: rotations don&#39;t change</span>
<span class="sd">the distance of a point from the origin.</span>
<span class="sd">-/</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">rotation_preserves_norm_squared</span><span class="w"> </span><span class="o">(</span><span class="n">R</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">isOrthogonal</span><span class="w"> </span><span class="n">R</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">normSquared</span><span class="w"> </span><span class="o">(</span><span class="n">rotate</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">normSquared</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">unfold</span><span class="w"> </span><span class="n">normSquared</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="n">isOrthogonal</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="bp">*</span>
<span class="w">  </span><span class="n">obtain</span><span class="w"> </span><span class="o">⟨</span><span class="n">h1</span><span class="o">,</span><span class="w"> </span><span class="n">h2</span><span class="o">,</span><span class="w"> </span><span class="n">h3</span><span class="o">,</span><span class="w"> </span><span class="n">h4</span><span class="o">,</span><span class="w"> </span><span class="n">h5</span><span class="o">,</span><span class="w"> </span><span class="n">h6</span><span class="o">⟩</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h</span>
<span class="w">  </span><span class="c1">-- The proof: expand the LHS and use orthogonality conditions</span>
<span class="w">  </span><span class="k">calc</span><span class="w"> </span><span class="o">(</span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">)</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span>
<span class="w">       </span><span class="o">(</span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">)</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span>
<span class="w">       </span><span class="o">(</span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">)</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">)</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m00</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m20</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span>
<span class="w">        </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m01</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m21</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span>
<span class="w">        </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m02</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m22</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m22</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span>
<span class="w">        </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m01</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m21</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span>
<span class="w">        </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m00</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m10</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m20</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m22</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span>
<span class="w">        </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">R.m01</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m02</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m11</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m12</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">R.m21</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">R.m22</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">ring</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">+</span>
<span class="w">        </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">          </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">h1</span><span class="o">,</span><span class="w"> </span><span class="n">h2</span><span class="o">,</span><span class="w"> </span><span class="n">h3</span><span class="o">,</span><span class="w"> </span><span class="n">h4</span><span class="o">,</span><span class="w"> </span><span class="n">h5</span><span class="o">,</span><span class="w"> </span><span class="n">h6</span><span class="o">]</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">ring</span>

<span class="sd">/--</span>
<span class="sd">THEOREM: Translation changes position but preserves relative distances.</span>
<span class="sd">The norm changes by a predictable amount based on the translation vector.</span>
<span class="sd">-/</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">translation_norm_relation</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Translation</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">normSquared</span><span class="w"> </span><span class="o">(</span><span class="n">translate</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span>
<span class="w">    </span><span class="n">normSquared</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">t.dx</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">t.dy</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">t.dz</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">p.z</span><span class="o">)</span>
<span class="w">    </span><span class="bp">+</span><span class="w"> </span><span class="n">normSquared</span><span class="w"> </span><span class="o">⟨</span><span class="n">t.dx</span><span class="o">,</span><span class="w"> </span><span class="n">t.dy</span><span class="o">,</span><span class="w"> </span><span class="n">t.dz</span><span class="o">⟩</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">unfold</span><span class="w"> </span><span class="n">normSquared</span><span class="w"> </span><span class="n">translate</span>
<span class="w">  </span><span class="n">ring</span>

<span class="sd">/--</span>
<span class="sd">THEOREM: The identity rotation leaves points unchanged.</span>
<span class="sd">-/</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">identity_rotation_is_identity</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">rotate</span><span class="w"> </span><span class="n">identityRotation</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">unfold</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="n">identityRotation</span>
<span class="w">  </span><span class="n">simp</span>

<span class="sd">/--</span>
<span class="sd">THEOREM: The identity rotation is orthogonal.</span>
<span class="sd">-/</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">identity_is_orthogonal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">isOrthogonal</span><span class="w"> </span><span class="n">identityRotation</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">unfold</span><span class="w"> </span><span class="n">isOrthogonal</span><span class="w"> </span><span class="n">identityRotation</span>
<span class="w">  </span><span class="n">simp</span>

<span class="sd">/--</span>
<span class="sd">THEOREM: Rotation around the Z-axis is orthogonal for any angle θ.</span>
<span class="sd">This uses the fundamental trigonometric identity: cos²θ + sin²θ = 1</span>
<span class="sd">-/</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">rotationZ_is_orthogonal</span><span class="w"> </span><span class="o">(</span><span class="n">θ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ℝ</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">isOrthogonal</span><span class="w"> </span><span class="o">(</span><span class="n">rotationZ</span><span class="w"> </span><span class="n">θ</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span>
<span class="w">  </span><span class="n">unfold</span><span class="w"> </span><span class="n">isOrthogonal</span><span class="w"> </span><span class="n">rotationZ</span>
<span class="w">  </span><span class="n">constructor</span>
<span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">simp</span><span class="bp">;</span><span class="w"> </span><span class="n">ring_nf</span><span class="bp">;</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">Real.cos_sq_add_sin_sq</span><span class="w"> </span><span class="n">θ</span>
<span class="w">  </span><span class="n">constructor</span>
<span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">simp</span><span class="bp">;</span><span class="w"> </span><span class="n">ring_nf</span><span class="bp">;</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">Real.sin_sq</span><span class="o">,</span><span class="w"> </span><span class="n">Real.cos_sq</span><span class="o">]</span><span class="bp">;</span><span class="w"> </span><span class="n">ring</span>
<span class="w">  </span><span class="n">constructor</span>
<span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">ring</span>
<span class="w">  </span><span class="n">constructor</span>
<span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">ring</span>
<span class="w">  </span><span class="n">constructor</span>
<span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">ring</span>
<span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">ring</span>
</pre></div>
</div>
<p><strong>Properties That Can Be Verified</strong></p>
<p>The type system and proof system together ensure:</p>
<ol class="arabic simple">
<li><p><strong>Type Safety</strong>: We can’t accidentally mix 2D and 3D operations</p></li>
<li><p><strong>Geometric Correctness</strong>: Rotations preserve norms (proved formally)</p></li>
<li><p><strong>Composition Correctness</strong>: Transformations compose as expected</p></li>
<li><p><strong>No Silent Failures</strong>: Invalid operations are caught at compile time</p></li>
</ol>
<p>This approach is increasingly important in:</p>
<ul class="simple">
<li><p>Game engines (e.g., Unreal Engine, Unity)</p></li>
<li><p>CAD/CAM software</p></li>
<li><p>Robotics and autonomous vehicles</p></li>
<li><p>Scientific visualization</p></li>
<li><p>Virtual/Augmented reality systems</p></li>
</ul>
<p>By formally verifying these properties, we can guarantee correctness
before any graphics are rendered or simulations are run.</p>
<p><strong>Example Usage</strong></p>
<p>Below we demonstrate the transformation pipeline with concrete values.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/-- Example: A point at (1, 0, 0) -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">examplePoint</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">⟩</span>

<span class="sd">/-- Example: Rotate 90 degrees around Z-axis -/</span>
<span class="kd">noncomputable</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">rotate90Z</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rotationZ</span><span class="w"> </span><span class="o">(</span><span class="n">Real.pi</span><span class="w"> </span><span class="bp">/</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>

<span class="sd">/-- Example: Translate by (5, 3, 2) -/</span>
<span class="kd">def</span><span class="w"> </span><span class="n">exampleTranslation</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Translation</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">⟨</span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">⟩</span>

<span class="sd">/-- Apply the transformation pipeline -/</span>
<span class="kd">noncomputable</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">transformedPoint</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Point3D</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">transformPipeline</span><span class="w"> </span><span class="n">rotate90Z</span><span class="w"> </span><span class="n">exampleTranslation</span><span class="w"> </span><span class="n">examplePoint</span>
</pre></div>
</div>
<p><strong>Why This Matters:</strong></p>
<p>This example shows how dependent types ensure:</p>
<ul class="simple">
<li><p><strong>Compile-time correctness</strong>: Can’t mix incompatible dimensions</p></li>
<li><p><strong>Mathematical guarantees</strong>: Formal proofs of geometric properties</p></li>
<li><p><strong>Industry relevance</strong>: Same techniques used in game engines, robotics, CAD software</p></li>
</ul>
<p>The code is ready to use in Lean 4 with Mathlib imported. Feel free to extend it with additional rotations (X, Y axes), compose multiple rotations, or add more complex transformations! The entire code file is available <a class="reference download internal" download="" href="../_downloads/5bd444edfa9f8fe05f3823b3251712bc/CaseStudy.lean"><span class="xref download myst">here</span></a>!</p>
</section>
<section id="history">
<h2><span class="section-number">9.11. </span>History<a class="headerlink" href="#history" title="Permalink to this heading">#</a></h2>
<p>Type theory and the idea of types as a foundation for mathematics and computation have a long pedigree that connects philosophical logic, lambda calculus, and modern proof assistants.</p>
<p>The story begins with early efforts to avoid paradoxes in naive set theory and logic (Russell, Frege), which motivated ramified and then simple type theories in the first half of the 20th century. Alonzo Church’s formulation of the simple theory of types and the simply-typed lambda calculus provided the computational backbone that later researchers built on. (<a class="reference external" href="https://en.wikipedia.org/wiki/History_of_type_theory">Wikipedia</a>)</p>
<p>A decisive shift toward dependent types occurred with Per Martin-Löf’s intuitionistic type theory (1970s–1980s). Martin-Löf introduced dependent function (<span class="math notranslate nohighlight">\(\Pi\)</span>) and dependent pair (<span class="math notranslate nohighlight">\(\Sigma\)</span>) types, giving a constructive foundation in which types can quantify over values. This made it possible to represent propositions as types and proofs as programs in a very expressive way. The Curry–Howard correspondence, the observation that proofs correspond to programs and propositions to types, fused logic and computation and underpins modern dependently-typed systems. (<a class="reference external" href="https://plato.stanford.edu/entries/type-theory">See here</a>)</p>
<p>In the 1980s and 1990s the field consolidated around a handful of influential calculi and systems. The Calculus of Constructions (Coquand &amp; Huet) and the later Calculus of Inductive Constructions became the basis for the Coq proof assistant; Agda and other systems explored dependently typed programming more directly; and the so-called lambda-cube classified a spectrum of type systems. Over the last two decades these theoretical advances have been implemented in robust systems (Coq, Agda, Lean, Idris) and large collaborative libraries (e.g., Lean’s mathlib), enabling both deep mathematical formalization and practical verification projects. (<a class="reference external" href="https://plato.stanford.edu/entries/type-theory">See here</a>)</p>
</section>
<section id="formal-methods-and-ai">
<h2><span class="section-number">9.12. </span>Formal Methods and AI<a class="headerlink" href="#formal-methods-and-ai" title="Permalink to this heading">#</a></h2>
<p>The integration of artificial intelligence with Lean and dependent type theory represents one of the most promising frontiers in automated reasoning. This convergence combines the rigor and certainty of formal verification with the pattern-matching and generalization capabilities of modern machine learning systems, creating powerful new approaches to mathematical theorem proving and software verification.</p>
<section id="infrastructure-for-ai-driven-theorem-proving">
<h3><span class="section-number">9.12.1. </span>Infrastructure for AI-Driven Theorem Proving<a class="headerlink" href="#infrastructure-for-ai-driven-theorem-proving" title="Permalink to this heading">#</a></h3>
<p>A critical challenge in applying machine learning to theorem proving is the gap between the Python-based machine learning ecosystem and the specialized environments of proof assistants. LeanDojo addresses this by providing foundational infrastructure that bridges Python-based machine learning with the Lean prover, extracting rich datasets from Lean repositories including abstract syntax trees, file dependencies, proof states, tactics, and fine-grained premise annotations (Yang et al., 2023). The tool transforms Lean into a gym-like environment where AI agents can programmatically observe proof states, submit tactics, and receive feedback, which is indispensable for evaluation, deployment, and reinforcement learning.</p>
<p>The LeanDojo project also introduced substantial benchmarks for training machine learning models. The original LeanDojo Benchmark contains 98,734 theorems and proofs with 217,776 tactics extracted from Mathlib, while the Lean 4 version includes 122,517 theorems with 259,580 tactics (Yang et al., 2023). A key innovation is the challenging data split design, which requires models to generalize to theorems relying on novel premises never used in training, rather than simply memorizing similar proofs (Yang et al., 2023).</p>
</section>
<section id="retrieval-augmented-language-models">
<h3><span class="section-number">9.12.2. </span>Retrieval-Augmented Language Models<a class="headerlink" href="#retrieval-augmented-language-models" title="Permalink to this heading">#</a></h3>
<p>One of the key bottlenecks in automated theorem proving is premise selection—identifying relevant existing lemmas and definitions from vast mathematical libraries to apply in proofs. ReProver (Retrieval-Augmented Prover) represents a significant advance, combining language models with retrieval mechanisms for selecting premises from large mathematics libraries, requiring only one GPU week of training (Yang et al., 2023). The retrieval component leverages LeanDojo’s program analysis to identify accessible premises and hard negative examples, making retrieval substantially more effective than baseline approaches.</p>
<p>More recently, researchers have developed methods for generating massive training datasets. LeanNavigator generates new theorems by exploring state transition graphs of existing Lean theorems, producing 4.7 million theorems totaling 1 billion tokens from Mathlib4, surpassing previous datasets by more than an order of magnitude (Li et al., 2025). Models trained on this expanded dataset outperform previous state-of-the-art systems like ReProver in theorem-proving benchmarks.</p>
</section>
<section id="integration-with-large-language-models">
<h3><span class="section-number">9.12.3. </span>Integration with Large Language Models<a class="headerlink" href="#integration-with-large-language-models" title="Permalink to this heading">#</a></h3>
<p>The emergence of powerful large language models has opened new possibilities for human-AI collaboration in formal mathematics. Lean Copilot allows large language models to be used natively in Lean for proof automation, suggesting tactics and premises and searching for proofs using built-in models from LeanDojo or custom models running locally or remotely (Song et al., 2024). This integration enables more natural interaction patterns where AI systems can interleave informal mathematical reasoning with formal proof steps.</p>
<p>Commercial and research applications are proliferating. In 2022, OpenAI and Meta AI independently created AI models to generate proofs of high-school-level olympiad problems in Lean, demonstrating that large language models can interface effectively with formal proof environments (<a class="reference external" href="https://scholar.google.com/scholar?q=Lean+proof+assistant">Wikipedia</a>, 2024). More recently, systems like AlphaProof from Google DeepMind have achieved silver-medal performance at the International Mathematical Olympiad using reinforcement learning trained on Lean (Google DeepMind, 2024).</p>
</section>
<section id="challenges-and-future-directions">
<h3><span class="section-number">9.12.4. </span>Challenges and Future Directions<a class="headerlink" href="#challenges-and-future-directions" title="Permalink to this heading">#</a></h3>
<p>Despite significant progress, substantial challenges remain. Formalizing real-world knowledge or large codebases in Lean remains labor-intensive, and Lean requires precise problem specification, which isn’t straightforward for messy real-world scenarios. Auto-formalization efforts—where AI converts informal specifications into Lean code—are underway but not yet seamless.</p>
<p>The trajectory, however, is promising. As one analysis notes, every improvement in AI reasoning capabilities—better chain-of-thought reasoning, specialized training on formal tasks—directly boosts Lean integration performance (VentureBeat AI, 2024). The convergence of human expertise, community knowledge, and AI assistance hints at a collaborative future for formal methods where mathematical superintelligence becomes achievable through the synergy of human insight and machine verification.</p>
</section>
</section>
<section id="current-development">
<h2><span class="section-number">9.13. </span>Current Development<a class="headerlink" href="#current-development" title="Permalink to this heading">#</a></h2>
<p>Lean and its ecosystem continue to evolve rapidly, driven by both community contributions and institutional support. The development landscape encompasses advances in the core language, expansion of mathematical libraries, organizational infrastructure, and high-profile mathematical formalization projects.</p>
<section id="institutional-support-and-the-lean-fro">
<h3><span class="section-number">9.13.1. </span>Institutional Support and the Lean FRO<a class="headerlink" href="#institutional-support-and-the-lean-fro" title="Permalink to this heading">#</a></h3>
<p>In July 2023, the Lean Focused Research Organization (FRO) was established as a non-profit under Convergent Research, pursuing a focused 5-year mission to improve Lean’s critical systems through enhanced scalability, usability, documentation, and proof automation (Lean FRO, 2024). The FRO is led by Chief Architect Leonardo de Moura, who created Lean in 2013, alongside Head of Engineering Sebastian Ullrich, and is funded by the Alfred P. Sloan Foundation, Simons Foundation International, Richard Merkin Foundation, and private donors including Alex Gerko.</p>
<p>In its first year of operation, the FRO achieved measurable progress across key metrics: monthly active users increased 49%, the number of packages grew 372%, and the number of courses using Lean increased 89% year-over-year (Lean FRO, 2024). The organization hired eleven team members, established governance structures, and secured sufficient funding to ensure Lean’s path toward self-sufficiency. Focus areas included improving compilation speed, enhancing documentation, developing proof automation tools like the omega tactic for integer and natural number reasoning, and launching Reservoir, Lean’s package repository.</p>
</section>
<section id="mathlib4-development">
<h3><span class="section-number">9.13.2. </span>Mathlib4 Development<a class="headerlink" href="#mathlib4-development" title="Permalink to this heading">#</a></h3>
<p>The community-maintained Mathlib library represents one of the most comprehensive formalizations of mathematics in any proof assistant. As of May 2025, Mathlib had formalized over 210,000 theorems and 100,000 definitions in Lean, spanning areas from undergraduate mathematics through research-level topics (<a class="reference external" href="https://scholar.google.com/scholar?q=Lean+proof+assistant">Wikipedia</a>, 2025).</p>
<p>The transition from Lean 3 to Lean 4 required porting the entire Mathlib library—a massive community effort. July 2023 marked the completion of the project to port Lean’s mathematics library from Lean 3 to Lean 4, enabling the community to focus on expansion rather than migration (Buzzard, 2024). Lean 4’s redesigned typeclass inference system, which incorporated insights from Mathlib development, eliminated the need for many typeclass linters that were necessary in Lean 3 (Baanen et al., 2022).</p>
<p>Managing a library of this scale presents unique challenges. The community employs sophisticated tooling including automated continuous integration, code quality linters, a deprecation system for managing breaking changes, and the bors merge bot to ensure the main branch always passes all tests (Baanen et al., 2022). Development is coordinated through GitHub and the Lean Zulip chat, where contributors at all expertise levels participate in design discussions and receive guidance.</p>
</section>
<section id="high-profile-formalization-projects">
<h3><span class="section-number">9.13.3. </span>High-Profile Formalization Projects<a class="headerlink" href="#high-profile-formalization-projects" title="Permalink to this heading">#</a></h3>
<p>Several ambitious mathematical formalization projects have demonstrated Lean’s capabilities and attracted attention from prominent mathematicians. In 2023, Fields Medalist Terence Tao led a collaborative project to formalize the proof of the Polynomial Freiman-Ruzsa (PFR) conjecture in Lean 4, completed within weeks of the original paper’s release (Tao, 2023). The project utilized Patrick Massot’s Blueprint tool, which links human-readable proof outlines to formal Lean code, facilitating large-scale collaboration.</p>
<p>Tao has continued his engagement with Lean formalization. In May 2025, Tao released a Lean companion to his textbook “Analysis I,” formalizing foundational real analysis topics including constructions of number systems, sequences, series, continuity, differentiation, and integration (Tao, 2025). The formalization serves dual purposes: as an annotated companion to the textbook and as an introduction to relevant portions of Mathlib, gradually transitioning from textbook definitions to Mathlib conventions.</p>
<p>Other major ongoing projects include the Fermat’s Last Theorem formalization project, established in December 2023, which aims to formalize one of mathematics’ most complex proofs (Lean FRO, 2024). In 2021, researchers used Lean to verify Peter Scholze’s proof in condensed mathematics, garnering attention for formalizing cutting-edge mathematical research (<a class="reference external" href="https://scholar.google.com/scholar?q=Lean+proof+assistant">Wikipedia</a>, 2024).</p>
</section>
<section id="commercial-and-research-ecosystem">
<h3><span class="section-number">9.13.4. </span>Commercial and Research Ecosystem<a class="headerlink" href="#commercial-and-research-ecosystem" title="Permalink to this heading">#</a></h3>
<p>The Lean ecosystem has expanded beyond academia into commercial applications. In June 2024, Harmonic launched as the first startup based on Lean, covered in The New York Times, focusing on reducing AI hallucinations through formal verification (Lean FRO, 2024). Other recent developments include Velvet, a verifier for imperative programs released in October 2025, and Axiom, which aims to build quantitative superintelligence using formal methods.</p>
<p>The Lean VS Code development environment surpassed 100,000 installations in September 2025, indicating growing adoption (Lean FRO, 2024). Academic partnerships continue to deepen, with institutions like Carnegie Mellon University’s Hoskinson Center and L3 Lab at the University of Washington conducting research at the intersection of Lean and AI.</p>
</section>
<section id="recognition-and-future-outlook">
<h3><span class="section-number">9.13.5. </span>Recognition and Future Outlook<a class="headerlink" href="#recognition-and-future-outlook" title="Permalink to this heading">#</a></h3>
<p>In 2025, the ACM SIGPLAN Programming Languages Software Award was awarded to Gabriel Ebner, Soonho Kong, Leonardo de Moura, and Sebastian Ullrich for Lean, recognizing its significant impact on mathematics, hardware and software verification, and AI (<a class="reference external" href="https://scholar.google.com/scholar?q=Lean+proof+assistant">Wikipedia</a>, 2025). This recognition reflects Lean’s evolution from an academic research project into a platform with broad impact across multiple domains.</p>
<p>Looking forward, the Lean FRO’s roadmap emphasizes continued investment in scalability, improved tooling for diverse user communities from mathematicians to verification engineers, and deeper integration with AI-assisted reasoning systems. The community’s ambitious formalization projects, combined with growing institutional support and commercial interest, position Lean as a central platform for the formal verification revolution in both mathematics and computer science.</p>
</section>
</section>
<section id="resources">
<h2><span class="section-number">9.14. </span>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://lean-lang.org/install/">Lean4 Installation</a></p></li>
<li><p><a class="reference external" href="https://adam.math.hhu.de/#/g/trequetrum/lean4game-logic">Lean Game Logic</a></p></li>
<li><p>Barnes (2011) <a class="reference external" href="https://scholar.google.com/scholar?q=Experiences+in+the+Industrial+use+of+Formal+Methods+Barnes">Experiences in the Industrial use of Formal Methods</a>, ECEASST 46</p></li>
<li><p>Ganesh, Seshia, and Jha (2022) <a class="reference external" href="https://scholar.google.com/scholar?q=Machine+learning+and+logic+a+new+frontier+in+artificial+intelligence+Ganesh+Seshia+Jha">Machine learning and logic: a new frontier in artificial intelligence</a>, Formal Methods Systems Design 60</p></li>
<li><p>Gleirscher and Marmsoler (2020) <a class="reference external" href="https://scholar.google.com/scholar?q=Formal+methods+in+dependable+systems+engineering+a+survey+of+professionals+Gleirscher+Marmsoler">Formal methods in dependable systems engineering: a survey of professionals from Europe and North America</a>, Empir Software Eng 25</p></li>
<li><p>Groote and Huisman (2024) <a class="reference external" href="https://scholar.google.com/scholar?q=%E2%80%9CFormal+Methods+for+Industrial+Critical+Systems%E2%80%9D&amp;hl=en&amp;as_sdt=0%2C5&amp;as_ylo=2024&amp;as_yhi=">Formal Methods for Industrial Critical Systems</a>, Int J Softw Tools Technol Transfer 26</p></li>
<li><p>Iliasov et al. (2021) <a class="reference external" href="https://scholar.google.com/scholar?q=Industrial-Strength+Verification+of+Solid+State+Interlocking+Programs+Iliasov">Industrial-Strength Verification of Solid State Interlocking Programs</a>, arXiv</p></li>
<li><p>Miranda et al. (2025) <a class="reference external" href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;as_ylo=2024&amp;q=%22VeriBench%3A+End-to-End+formal+verification+benchmark+for+AI+code+generation+in+Lean+4%22&amp;btnG=">VeriBench: End-to-End formal verification benchmark for AI code generation in Lean 4</a>, Proceedings of ICML 2025</p></li>
<li><p>Singh et al. (2019) <a class="reference external" href="https://scholar.google.com/scholar?q=Symbolic+QED+Pre-silicon+Verification+for+Automotive+Microcontroller+Cores+Singh">Symbolic QED Pre-silicon Verification for Automotive Microcontroller Cores: Industrial Case Study</a>, arXiv</p></li>
<li><p>Stanford Encyclopedia of Philosophy (2022) <a class="reference external" href="https://plato.stanford.edu/entries/type-theory">Type Theory</a>, Stanford Encyclopedia of Philosophy</p></li>
<li><p>Stanford Encyclopedia of Philosophy (2024) <a class="reference external" href="https://plato.stanford.edu/entries/type-theory-intuitionistic/">Intuitionistic Type Theory</a>, Stanford Encyclopedia of Philosophy</p></li>
<li><p>Stock, Dunkelau, and Mashkoor (2025) <a class="reference external" href="https://scholar.google.com/scholar?q=Application+of+AI+to+formal+methods+an+analysis+of+current+trends+Stock+Dunkelau+Mashkoor">Application of AI to formal methods — an analysis of current trends</a>, Empir Software Eng</p></li>
<li><p>Wadler (2015) <a class="reference external" href="https://scholar.google.com/scholar?q=Propositions+as+Types+Wadler">Propositions as Types</a>, Communications of the ACM 58(12)</p></li>
<li><p>Bauer and Komel (2020) <a class="reference external" href="https://scholar.google.com/scholar?q=Equality+checking+for+general+type+theories+in+Andromeda+2+Bauer+Komel">Equality checking for general type theories in Andromeda 2</a>, International Conference on Interactive Theorem Proving</p></li>
<li><p>Bauer and Komel (2022) <a class="reference external" href="https://scholar.google.com/scholar?q=An+extensible+equality+checking+algorithm+for+dependent+type+theories+Bauer+Komel">An extensible equality checking algorithm for dependent type theories</a>, Logical Methods in Computer Science</p></li>
<li><p>de Moura et al. (2021) <a class="reference external" href="https://scholar.google.com/scholar?q=The+Lean+4+theorem+prover+and+programming+language+de+Moura">The Lean 4 theorem prover and programming language</a>, International Conference on Automated Deduction</p></li>
<li><p>Dunfield and Krishnaswami (2021) <a class="reference external" href="https://scholar.google.com/scholar?q=Bidirectional+typing+Dunfield+Krishnaswami">Bidirectional typing</a>, ACM Computing Surveys</p></li>
<li><p>Ebner et al. (2017) <a class="reference external" href="https://scholar.google.com/scholar?q=A+metaprogramming+framework+for+formal+verification+Ebner">A metaprogramming framework for formal verification</a>, Proceedings of the ACM on Programming Languages</p></li>
<li><p>Felicissimo (2024) <a class="reference external" href="https://scholar.google.com/scholar?q=Generic+bidirectional+typing+for+dependent+type+theories+artifact+Felicissimo">Artifact report: Generic bidirectional typing for dependent type theories</a>, ESOP 2024</p></li>
<li><p>Felicissimo et al. (2024) <a class="reference external" href="https://scholar.google.com/scholar?q=Generic+bidirectional+typing+for+dependent+type+theories+Felicissimo">Generic bidirectional typing for dependent type theories</a>, ESOP 2024</p></li>
<li><p>Ko and Gibbons (2024) <a class="reference external" href="https://scholar.google.com/scholar?q=A+formal+treatment+of+bidirectional+typing+Ko+Gibbons">A formal treatment of bidirectional typing</a>, ESOP 2024</p></li>
<li><p>Lean Community (n.d.) <a class="reference external" href="https://leanprover-community.github.io/lean4-metaprogramming-book/">Metaprogramming in Lean 4</a>, Online documentation</p></li>
<li><p>Azerbayev et al. (2023) <a class="reference external" href="https://scholar.google.com/scholar?q=ProofNet+Autoformalizing+and+formally+proving+undergraduate-level+mathematics+Azerbayev">ProofNet: Autoformalizing and formally proving undergraduate-level mathematics</a>, arXiv</p></li>
<li><p>DeepSeek (2025) <a class="reference external" href="https://scholar.google.com/scholar?q=DeepSeek-Prover-V2+Retrieval+augmented+Lean+prover+DeepSeek">DeepSeek-Prover-V2: Retrieval augmented Lean prover for mathematical reasoning</a>, arXiv</p></li>
<li><p>Google DeepMind (2024) <a class="reference external" href="https://deepmind.google/blog/ai-solves-imo-problems-at-silver-medal-level/">AI achieves silver-medal standard solving International Mathematical Olympiad problems</a>, Blog post</p></li>
<li><p>Google DeepMind (2025) <a class="reference external" href="https://deepmind.google/blog/advanced-version-of-gemini-with-deep-think-officially-achieves-gold-medal-standard-at-the-international-mathematical-olympiad/">Advanced version of Gemini with Deep Think officially achieves gold-medal standard at the International Mathematical Olympiad</a>, Blog post</p></li>
<li><p>IMO Grand Challenge (n.d.) <a class="reference external" href="https://imo-grand-challenge.github.io/">IMO Grand Challenge for Artificial Intelligence</a>, Project website</p></li>
<li><p>Liu et al. (2023) <a class="reference external" href="https://scholar.google.com/scholar?q=FIMO+A+challenge+formal+dataset+for+automated+theorem+proving+Liu">FIMO: A challenge formal dataset for automated theorem proving</a>, arXiv</p></li>
<li><p>Sutcliffe (2016) <a class="reference external" href="https://scholar.google.com/scholar?q=The+CADE+ATP+system+competition+CASC+Sutcliffe">The CADE ATP system competition—CASC</a>, AI Magazine</p></li>
<li><p>Team et al. (2025) <a class="reference external" href="https://scholar.google.com/scholar?q=LeanGeo+Formalizing+competitional+geometry+problems+in+Lean+Team">LeanGeo: Formalizing competitional geometry problems in Lean</a>, arXiv</p></li>
<li><p>Tsoukalas et al. (2024) <a class="reference external" href="https://scholar.google.com/scholar?q=PutnamBench+Evaluating+neural+theorem-provers+Tsoukalas">PutnamBench: Evaluating neural theorem-provers</a>, NeurIPS 2024</p></li>
<li><p>Wang et al. (2025) <a class="reference external" href="https://scholar.google.com/scholar?q=REAL-Prover+Retrieval+augmented+Lean+prover+Wang">REAL-Prover: Retrieval augmented Lean prover for mathematical reasoning</a>, arXiv</p></li>
<li><p>Zheng, Han, and Polu (2021) <a class="reference external" href="https://scholar.google.com/scholar?q=MiniF2F+A+cross-system+benchmark+for+formal+Olympiad-level+mathematics+Zheng+Han+Polu">MiniF2F: A cross-system benchmark for formal Olympiad-level mathematics</a>, ICLR 2022</p></li>
<li><p>Li et al. (2025) <a class="reference external" href="https://scholar.google.com/scholar?q=Generating+millions+of+Lean+theorems+with+proofs+by+exploring+state+transition+graphs+Li">Generating millions of Lean theorems with proofs by exploring state transition graphs</a>, arXiv</p></li>
<li><p>Song, Yang, and Anandkumar (2024) <a class="reference external" href="https://scholar.google.com/scholar?q=Lean+Copilot+Large+language+models+as+copilots+for+theorem+proving+Song+Yang+Anandkumar">Lean Copilot: Large language models as copilots for theorem proving in Lean</a>, arXiv</p></li>
<li><p>VentureBeat AI (2024) <a class="reference external" href="https://beamstart.com/news/lean4-how-the-theorem-prover-17638530282056">Lean4: How the theorem prover is revolutionizing AI and mathematics</a>, Article</p></li>
<li><p>Yang et al. (2023) <a class="reference external" href="https://scholar.google.com/scholar?q=LeanDojo+Theorem+proving+with+retrieval-augmented+language+models+Yang">LeanDojo: Theorem proving with retrieval-augmented language models</a>, NeurIPS 2023</p></li>
<li><p>Baanen et al. (2022) <a class="reference external" href="https://scholar.google.com/scholar?q=Growing+Mathlib+Maintenance+of+a+large+scale+mathematical+library+Baanen">Growing Mathlib: Maintenance of a large scale mathematical library</a>, Intelligent Computer Mathematics</p></li>
<li><p>Buzzard (2024) <a class="reference external" href="https://xenaproject.wordpress.com/2024/01/20/lean-in-2024/">Lean in 2024</a>, Xena Project blog</p></li>
<li><p>Lean FRO (2024) <a class="reference external" href="https://lean-fro.org/about/">About the Lean FRO</a>, Organization website</p></li>
<li><p>Lean FRO (2024) <a class="reference external" href="https://lean-lang.org/blog/2024-8-13-lean-fro-year-1-in-review/">Lean FRO year 1 in review</a>, Blog post</p></li>
<li><p>Tao (2023) <a class="reference external" href="https://terrytao.wordpress.com/2023/11/18/formalizing-the-proof-of-pfr-in-lean4-using-blueprint-a-short-tour/">Formalizing the proof of PFR in Lean4 using Blueprint: A short tour</a>, What’s New blog</p></li>
<li><p>Tao (2025) <a class="reference external" href="https://terrytao.wordpress.com/2025/05/31/a-lean-companion-to-analysis-i/">A Lean companion to “Analysis I”</a>, What’s New blog</p></li>
</ul>
</section>
<section id="future-work">
<h2><span class="section-number">9.15. </span>Future Work<a class="headerlink" href="#future-work" title="Permalink to this heading">#</a></h2>
<p>For future work, find more relevant sources, specifically to Lean, for Applications in Industry. Additionally, include more algorithms and properties of Dependent Type Theory. Please extend and explore more in depth any topics that were not thoroughly covered in this chapter. Finally, include additional different case studies for Lean to demonstrate how Lean can be applied to different fields.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./content"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="08-higher-order-logic-isabelle.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8. </span>Higher-Order Logic with Isabelle</p>
      </div>
    </a>
    <a class="right-next"
       href="appendix-hoare-logic.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Hoare Logic</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">9.1. Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#idea">9.2. Idea</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-theory">9.3. Basic Theory</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-curry-howard-correspondence">9.3.1. The Curry-Howard Correspondence</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tool">9.4. Tool</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introductory-examples">9.5. Introductory Examples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logic-game">9.5.1. Logic Game</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#immediate-feedback-loop">9.5.1.1. Immediate Feedback Loop</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-mental-model-of-lean">9.5.1.2. The “Mental Model” of Lean</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#encourages-experimentation">9.5.1.3. Encourages Experimentation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#natural-number-game">9.5.2. Natural Number Game</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#how-mathematics-can-be-built-from-axiom">9.5.2.1. How Mathematics Can Be Built From Axiom</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#inductive-reasoing-through-direct-interaction">9.5.2.2. Inductive Reasoing Through Direct Interaction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#motivates-algorithmic-thinking">9.5.2.3. Motivates Algorithmic Thinking</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-landscape-of-tools">9.6. The Landscape of Tools</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms">9.7. Algorithms</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bidirectional-typechecking-type-inference-type-checking-separation">9.7.1. Bidirectional typechecking / type-inference + type-checking separation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equality-normalization-conversion-extensionality-checking">9.7.2. Equality / Normalization / Conversion / Extensionality Checking</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elaboration">9.7.3. Elaboration</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#combined-algorithmic-stack-decidability-trust">9.7.4. Combined algorithmic stack: Decidability + Trust</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#benchmarks-and-competitions">9.8. Benchmarks and Competitions</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-competition-benchmarks">9.8.1. Mathematical Competition Benchmarks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-imo-grand-challenge">9.8.2. The IMO Grand Challenge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classical-automated-theorem-proving-competitions">9.8.3. Classical Automated Theorem Proving Competitions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recent-developments-and-ai-integration">9.8.4. Recent Developments and AI Integration</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-in-industry">9.9. Applications in Industry</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#historical-and-influencial-application">9.9.1. Historical and Influencial Application</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recent-emerging-directions">9.9.2. Recent &amp; Emerging Directions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#case-study">9.10. Case Study</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#history">9.11. History</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#formal-methods-and-ai">9.12. Formal Methods and AI</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#infrastructure-for-ai-driven-theorem-proving">9.12.1. Infrastructure for AI-Driven Theorem Proving</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#retrieval-augmented-language-models">9.12.2. Retrieval-Augmented Language Models</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#integration-with-large-language-models">9.12.3. Integration with Large Language Models</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#challenges-and-future-directions">9.12.4. Challenges and Future Directions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#current-development">9.13. Current Development</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#institutional-support-and-the-lean-fro">9.13.1. Institutional Support and the Lean FRO</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathlib4-development">9.13.2. Mathlib4 Development</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#high-profile-formalization-projects">9.13.3. High-Profile Formalization Projects</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#commercial-and-research-ecosystem">9.13.4. Commercial and Research Ecosystem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recognition-and-future-outlook">9.13.5. Recognition and Future Outlook</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#resources">9.14. Resources</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#future-work">9.15. Future Work</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By CPSC 510
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>